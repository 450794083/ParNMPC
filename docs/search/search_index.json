{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC Version 1808-1 ( Github: ParNMPC ) has been released! Introduction ParNMPC is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). ParNMPC can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of \\mu \\mu s). The purpose of ParNMPC is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment. Features Symbolic problem representation Automatic parallel C/C++ code generation with OpenMP Fast rate of convergence (up to be superlinear) Highly parallelizable (capable of using at most N cores, N is the # of discretization steps) High speedup ratio MATLAB Simulink Problems Supported in ParNMPC The optimization control problem (OCP) supported in ParNMPC has the following form: \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)} \\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad x(0) = \\bar{x}_0,\\\\ M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\ x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\ G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T]. \\end{align} \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\ & x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\ & G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T]. \\end{align} Here, Sign Size Description Sign Size Description u u [uDim,1] Input vector L L [1,1] Cost function x x [xDim,1] State vector C C [muDim,1] Equality constraint function p p [pDim,1] Given parameter vector f f [xDim,1] Dynamics T T [1,1] Prediction horizon M M [xDim,xDim] (Optional, e.g., Lagrange model) \\bar{x}_0 \\bar{x}_0 [xDim,1] Current state vector G G [GDim,1] Polytopic constraint function ( G G is linear in u u and x x ) u_{min} u_{min} [uDim,1] Lower bound of u u u_{max} u_{max} [uDim,1] Upper bound of u u x_{min} x_{min} [xDim,1] Lower bound of x x x_{max} x_{max} [xDim,1] Upper bound of x x G_{min} G_{min} [GDim,1] Lower bound of G G G_{max} G_{max} [GDim,1] Upper bound of G G Note Varying dynamics, prediction horizon and references, and terminal cost function can be achieved by using the parameter p p . How ParNMPC Solves the OCP? Discretization ParNMPC discretizes the OCP defined above into the following problem with N N steps: \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ & x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, the continuous-time state equation \\dot{x}(t)=f(u(t),x(t),p(t)) \\dot{x}(t)=f(u(t),x(t),p(t)) (if M M is not imposed) is discretized to be F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 , e.g., the backward Euler's method with F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i , where \\Delta\\tau=T/N \\Delta\\tau=T/N . Handling inequality constraints The inequality constraints are converted into logarithmic barrier functions (i.e., interior-point method). The following equality-constrained problem is obtained: \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\ \\text{s.t.}\\quad x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, v_{(j)} v_{(j)} is the j j -th element of a variable v v , G_{i(j)} G_{i(j)} is the j j -th element of G(u_i,x_i,p_i) G(u_i,x_i,p_i) , and \\gamma \\gamma is the barrier parameter. For simplicity, the same barrier parameter is used here. It can be set to be different for different constraints in ParNMPC . Solving the KKT conditions iteratively in parallel Then, ParNMPC derives the KKT conditions for the problem above by introducing Lagrange multipliers \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} for the state equations and \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} for the equality constraints. Next, the KKT conditions are solved iteratively in parallel for a given initial state \\bar{x}_0 \\bar{x}_0 and given parameters \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} . The NMPC controller is implemented by applying the first optimal control input u_1^* u_1^* as the actual input. Note The iterative solver of ParNMPC relies on warm start. ParNMPC provides tools to solve the very first OCP offline. ParNMPC provides tools to define the controlled plant model for simulation.","title":"What is ParNMPC"},{"location":"#parnmpc-a-parallel-computing-toolbox-for-nonlinear-mpc","text":"Version 1808-1 ( Github: ParNMPC ) has been released!","title":"ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC"},{"location":"#introduction","text":"ParNMPC is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). ParNMPC can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of \\mu \\mu s). The purpose of ParNMPC is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment.","title":"Introduction"},{"location":"#features","text":"Symbolic problem representation Automatic parallel C/C++ code generation with OpenMP Fast rate of convergence (up to be superlinear) Highly parallelizable (capable of using at most N cores, N is the # of discretization steps) High speedup ratio MATLAB Simulink","title":"Features"},{"location":"#problems-supported-in-parnmpc","text":"The optimization control problem (OCP) supported in ParNMPC has the following form: \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)} \\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad x(0) = \\bar{x}_0,\\\\ M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\ x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\ G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T]. \\end{align} \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\ & x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\ & G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T]. \\end{align} Here, Sign Size Description Sign Size Description u u [uDim,1] Input vector L L [1,1] Cost function x x [xDim,1] State vector C C [muDim,1] Equality constraint function p p [pDim,1] Given parameter vector f f [xDim,1] Dynamics T T [1,1] Prediction horizon M M [xDim,xDim] (Optional, e.g., Lagrange model) \\bar{x}_0 \\bar{x}_0 [xDim,1] Current state vector G G [GDim,1] Polytopic constraint function ( G G is linear in u u and x x ) u_{min} u_{min} [uDim,1] Lower bound of u u u_{max} u_{max} [uDim,1] Upper bound of u u x_{min} x_{min} [xDim,1] Lower bound of x x x_{max} x_{max} [xDim,1] Upper bound of x x G_{min} G_{min} [GDim,1] Lower bound of G G G_{max} G_{max} [GDim,1] Upper bound of G G Note Varying dynamics, prediction horizon and references, and terminal cost function can be achieved by using the parameter p p .","title":"Problems Supported in  ParNMPC"},{"location":"#how-parnmpc-solves-the-ocp","text":"","title":"How ParNMPC Solves the OCP?"},{"location":"#discretization","text":"ParNMPC discretizes the OCP defined above into the following problem with N N steps: \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ & x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, the continuous-time state equation \\dot{x}(t)=f(u(t),x(t),p(t)) \\dot{x}(t)=f(u(t),x(t),p(t)) (if M M is not imposed) is discretized to be F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 , e.g., the backward Euler's method with F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i , where \\Delta\\tau=T/N \\Delta\\tau=T/N .","title":"Discretization"},{"location":"#handling-inequality-constraints","text":"The inequality constraints are converted into logarithmic barrier functions (i.e., interior-point method). The following equality-constrained problem is obtained: \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\ \\text{s.t.}\\quad x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\ -\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, v_{(j)} v_{(j)} is the j j -th element of a variable v v , G_{i(j)} G_{i(j)} is the j j -th element of G(u_i,x_i,p_i) G(u_i,x_i,p_i) , and \\gamma \\gamma is the barrier parameter. For simplicity, the same barrier parameter is used here. It can be set to be different for different constraints in ParNMPC .","title":"Handling inequality constraints"},{"location":"#solving-the-kkt-conditions-iteratively-in-parallel","text":"Then, ParNMPC derives the KKT conditions for the problem above by introducing Lagrange multipliers \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} for the state equations and \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} for the equality constraints. Next, the KKT conditions are solved iteratively in parallel for a given initial state \\bar{x}_0 \\bar{x}_0 and given parameters \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} . The NMPC controller is implemented by applying the first optimal control input u_1^* u_1^* as the actual input. Note The iterative solver of ParNMPC relies on warm start. ParNMPC provides tools to solve the very first OCP offline. ParNMPC provides tools to define the controlled plant model for simulation.","title":"Solving the KKT conditions iteratively in parallel"},{"location":"about/","text":"About ParNMPC is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka. Citing ParNMPC Coming soon. Contacting Us Please do not hesitate to contact us if you have any questions. We would be very happy to hear your advices, experiences, stories, and contributions. You can contact us by: posting an issue on ParNMPC: Issue . E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp joining our QQ Group: 339029295 License ParNMPC is distributed under the GNU Lesser General Public License v3.0.","title":"About"},{"location":"about/#about","text":"ParNMPC is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.","title":"About"},{"location":"about/#citing-parnmpc","text":"Coming soon.","title":"Citing ParNMPC"},{"location":"about/#contacting-us","text":"Please do not hesitate to contact us if you have any questions. We would be very happy to hear your advices, experiences, stories, and contributions. You can contact us by: posting an issue on ParNMPC: Issue . E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp joining our QQ Group: 339029295","title":"Contacting Us"},{"location":"about/#license","text":"ParNMPC is distributed under the GNU Lesser General Public License v3.0.","title":"License"},{"location":"exp_damper/","text":"Semi-active Damper Example SemiActiveDamper/ Problem Description A vehicle contacts the wall through the spring and damper: The state vector of the system is x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where y y is the position of the vehicle. The input is the damping coefficient d d , which is constrained with 0\\leq d \\leq 1 0\\leq d \\leq 1 . The dynamic equation of this semi-active damper is m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where k = 1 k = 1 and m=1 m=1 . The task is to control the vehicle's position y y to 0 from an initial position. OCP in ParNMPC The inequality constraints are transfered into equality constraints by introducing an extra dummy input d_s d_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T . Input: u=[d,d_s] u=[d,d_s] . Parameter: p p is empty. L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s . C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} . f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T . Prediction horizon T=5 T=5 . Number of the discritization grids N=48 N=48 . Discretization method: Euler. Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC NMPC Problem Formulation . Example SemiActiveDamper/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example SemiActiveDamper/Simu_Simulink_Setup.m Deployment Example SemiActiveDamper/Simu_Simulink.slx","title":"Simulation: Semi-active Damper"},{"location":"exp_damper/#semi-active-damper","text":"Example SemiActiveDamper/","title":"Semi-active Damper"},{"location":"exp_damper/#problem-description","text":"A vehicle contacts the wall through the spring and damper: The state vector of the system is x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where y y is the position of the vehicle. The input is the damping coefficient d d , which is constrained with 0\\leq d \\leq 1 0\\leq d \\leq 1 . The dynamic equation of this semi-active damper is m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where k = 1 k = 1 and m=1 m=1 . The task is to control the vehicle's position y y to 0 from an initial position.","title":"Problem Description"},{"location":"exp_damper/#ocp-in-parnmpc","text":"The inequality constraints are transfered into equality constraints by introducing an extra dummy input d_s d_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T . Input: u=[d,d_s] u=[d,d_s] . Parameter: p p is empty. L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s . C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} . f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T . Prediction horizon T=5 T=5 . Number of the discritization grids N=48 N=48 . Discretization method: Euler.","title":"OCP in ParNMPC"},{"location":"exp_damper/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_damper/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC NMPC Problem Formulation . Example SemiActiveDamper/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_damper/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example SemiActiveDamper/Simu_Simulink_Setup.m Deployment Example SemiActiveDamper/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_double_pendulum/","text":"Double Inverted Pendulum on a Cart Example DoubleInvertedPendulum/ Where you can find this pendulum A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004. Problem Description Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. The pendulum we want to swing up is: The state vector of the system is x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} , where \\theta_0 \\theta_0 is the displacement of the cart, and where \\theta_1 \\theta_1 , \\theta_2 \\theta_2 are the pendulum angles. The control force u u is constrained with |u|\\leq 10 |u|\\leq 10 . The system is modeled as D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu with \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T . A terminal penalty function is imposed to swing up the pendulum. The task is to swing up the pendulum from the initial state x_0 = [0,\\pi,\\pi,0,0,0]^{T} x_0 = [0,\\pi,\\pi,0,0,0]^{T} . OCP in ParNMPC The underlying OCP defined in ParNMPC is formulated as: State: x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T . Input: u u with u_{max} = 10 u_{max} = 10 and u_{min} = -10 u_{min} = -10 . Parameter: p=[Q_d,R_d,\\gamma] p=[Q_d,R_d,\\gamma] . L(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 L(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 with Q=\\text{diag}(Q_d) Q=\\text{diag}(Q_d) and R=\\text{diag}(R_d) R=\\text{diag}(R_d) . f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] . M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) . Prediction horizon T=1.5 T=1.5 . Number of the discritization grids N=48 N=48 . Discretization method: Euler. Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC NMPC Problem Formulation . Example DoubleInvertedPendulum/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example DoubleInvertedPendulum/Simu_Simulink_Setup.m Deployment Example DoubleInvertedPendulum/Simu_Simulink.slx","title":"Simulation: Double Inverted Pendulum on a Cart"},{"location":"exp_double_pendulum/#double-inverted-pendulum-on-a-cart","text":"Example DoubleInvertedPendulum/ Where you can find this pendulum A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.","title":"Double Inverted Pendulum on a Cart"},{"location":"exp_double_pendulum/#problem-description","text":"Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. The pendulum we want to swing up is: The state vector of the system is x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} , where \\theta_0 \\theta_0 is the displacement of the cart, and where \\theta_1 \\theta_1 , \\theta_2 \\theta_2 are the pendulum angles. The control force u u is constrained with |u|\\leq 10 |u|\\leq 10 . The system is modeled as D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu with \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T . A terminal penalty function is imposed to swing up the pendulum. The task is to swing up the pendulum from the initial state x_0 = [0,\\pi,\\pi,0,0,0]^{T} x_0 = [0,\\pi,\\pi,0,0,0]^{T} .","title":"Problem Description"},{"location":"exp_double_pendulum/#ocp-in-parnmpc","text":"The underlying OCP defined in ParNMPC is formulated as: State: x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T . Input: u u with u_{max} = 10 u_{max} = 10 and u_{min} = -10 u_{min} = -10 . Parameter: p=[Q_d,R_d,\\gamma] p=[Q_d,R_d,\\gamma] . L(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 L(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 with Q=\\text{diag}(Q_d) Q=\\text{diag}(Q_d) and R=\\text{diag}(R_d) R=\\text{diag}(R_d) . f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] . M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) . Prediction horizon T=1.5 T=1.5 . Number of the discritization grids N=48 N=48 . Discretization method: Euler.","title":"OCP in ParNMPC"},{"location":"exp_double_pendulum/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_double_pendulum/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC NMPC Problem Formulation . Example DoubleInvertedPendulum/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_double_pendulum/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example DoubleInvertedPendulum/Simu_Simulink_Setup.m Deployment Example DoubleInvertedPendulum/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_heli/","text":"Helicopter Example Helicopter/ Where you can find this helicopter Quanser website. 3 DoF Helicopter . Model: Benchmark model of Quanser\u2019s 3 DOF Helicopter - 2018 Problem Description The state vector of the helicopter is x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} , where q = [\\epsilon,\\rho,\\lambda]^T q = [\\epsilon,\\rho,\\lambda]^T is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \\rho \\rho is set to be |\\rho|\\leq 1 |\\rho|\\leq 1 . The input vector is u=[V_f,V_b]^T u=[V_f,V_b]^T , where V_f V_f is the voltage on the front motor and V_b V_b is the voltage on the back motor. The control input is bounded by [0,0]^T \\leq u \\leq [20,20]^T [0,0]^T \\leq u \\leq [20,20]^T . The dynamics of the helicopter are given by the following equations: \\begin{align*} \\ddot{q} = -\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon \\\\ C_\\rho \\\\ C_\\lambda \\end{array} \\right]\\dot{q}\\\\ +K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho) 0 \\\\ 0 b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho) 0 \\end{array} \\right]u \\end{align*} \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} The task is to control the helicopter to track a given yaw reference. OCP in ParNMPC The state constraints are softened by introducing a slack variable \\rho_s \\rho_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T . Input: u=[V_f,V_b,\\rho_s]^T u=[V_f,V_b,\\rho_s]^T with u_{max}=[20,20,\\infty]^T u_{max}=[20,20,\\infty]^T and u_{min} = [0,0,0]^T u_{min} = [0,0,0]^T . Parameter: p=[Q_d,R_d,x_{ref},\\gamma]^T p=[Q_d,R_d,x_{ref},\\gamma]^T , where Q_d Q_d and R_d R_d are tuning parameters, x_{ref} x_{ref} is the varying reference, and \\gamma 0 \\gamma>0 is the barrier parameter. Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 and L_{penalty}(u,x,p)=1000\\rho_s^2 L_{penalty}(u,x,p)=1000\\rho_s^2 is the penalty function. Polytopic function (linear constraint): G = [\\rho - \\rho_s, \\rho + \\rho_s]^T G = [\\rho - \\rho_s, \\rho + \\rho_s]^T with G_{max}=[1,\\infty]^T G_{max}=[1,\\infty]^T and G_{min} = [-\\infty,-1]^T G_{min} = [-\\infty,-1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T=4 T=4 s. Number of the discritization grids N=48 N=48 . Discretization method: Euler. Experiment settings: CPU: i7-8700K. MATLAB R2015b + Microsoft Visual C++ 2015 (C) Tolerance: 1e-4. DoP: 4. Hessian approximation method: Newton. Closed-loop control using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC NMPC Problem Formulation . Example Helicopter/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Helicopter/Simulink_Setup.m Deployment Example Helicopter/Deploy_Simulink_R2015b.slx Add -openmp to the makefile provided by Quanser. Experiment results (left: first 15 seconds; right: last 15 seconds):","title":"Experiment: Helicopter"},{"location":"exp_heli/#helicopter","text":"Example Helicopter/ Where you can find this helicopter Quanser website. 3 DoF Helicopter . Model: Benchmark model of Quanser\u2019s 3 DOF Helicopter - 2018","title":"Helicopter"},{"location":"exp_heli/#problem-description","text":"The state vector of the helicopter is x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} , where q = [\\epsilon,\\rho,\\lambda]^T q = [\\epsilon,\\rho,\\lambda]^T is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \\rho \\rho is set to be |\\rho|\\leq 1 |\\rho|\\leq 1 . The input vector is u=[V_f,V_b]^T u=[V_f,V_b]^T , where V_f V_f is the voltage on the front motor and V_b V_b is the voltage on the back motor. The control input is bounded by [0,0]^T \\leq u \\leq [20,20]^T [0,0]^T \\leq u \\leq [20,20]^T . The dynamics of the helicopter are given by the following equations: \\begin{align*} \\ddot{q} = -\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon \\\\ C_\\rho \\\\ C_\\lambda \\end{array} \\right]\\dot{q}\\\\ +K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho) 0 \\\\ 0 b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho) 0 \\end{array} \\right]u \\end{align*} \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} The task is to control the helicopter to track a given yaw reference.","title":"Problem Description"},{"location":"exp_heli/#ocp-in-parnmpc","text":"The state constraints are softened by introducing a slack variable \\rho_s \\rho_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T . Input: u=[V_f,V_b,\\rho_s]^T u=[V_f,V_b,\\rho_s]^T with u_{max}=[20,20,\\infty]^T u_{max}=[20,20,\\infty]^T and u_{min} = [0,0,0]^T u_{min} = [0,0,0]^T . Parameter: p=[Q_d,R_d,x_{ref},\\gamma]^T p=[Q_d,R_d,x_{ref},\\gamma]^T , where Q_d Q_d and R_d R_d are tuning parameters, x_{ref} x_{ref} is the varying reference, and \\gamma 0 \\gamma>0 is the barrier parameter. Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 and L_{penalty}(u,x,p)=1000\\rho_s^2 L_{penalty}(u,x,p)=1000\\rho_s^2 is the penalty function. Polytopic function (linear constraint): G = [\\rho - \\rho_s, \\rho + \\rho_s]^T G = [\\rho - \\rho_s, \\rho + \\rho_s]^T with G_{max}=[1,\\infty]^T G_{max}=[1,\\infty]^T and G_{min} = [-\\infty,-1]^T G_{min} = [-\\infty,-1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T=4 T=4 s. Number of the discritization grids N=48 N=48 . Discretization method: Euler. Experiment settings: CPU: i7-8700K. MATLAB R2015b + Microsoft Visual C++ 2015 (C) Tolerance: 1e-4. DoP: 4. Hessian approximation method: Newton.","title":"OCP in ParNMPC"},{"location":"exp_heli/#closed-loop-control-using-parnmpc","text":"","title":"Closed-loop control using ParNMPC"},{"location":"exp_heli/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC NMPC Problem Formulation . Example Helicopter/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_heli/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Helicopter/Simulink_Setup.m Deployment Example Helicopter/Deploy_Simulink_R2015b.slx Add -openmp to the makefile provided by Quanser. Experiment results (left: first 15 seconds; right: last 15 seconds):","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_quadrotor/","text":"Quadrotor Example Quadrotor/ Where you can find this quadrotor M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d ICRA, Shanghai, China, 2011, pp. 763\u2013770. Problem Description The state vector of the quadrotor is x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where (X,Y,Z) (X,Y,Z) and (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha) are the position and angles of the quadrotor, respectively. The state is bounded by [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T . The input vector is u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where a a represents the thrust and (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z}) the rotational rates. The control input is bounded by [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T . The dynamics of the quadrotor are given by the following equations: \\begin{align} \\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ \\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ \\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ \\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ \\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ \\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} The task is to control the quadrotor to track a given position reference under a variable prediction horizon. OCP in ParNMPC The state constraints are softened by introducing slack variables \\dot{X}_s \\dot{X}_s , \\dot{Y}_s \\dot{Y}_s , and \\dot{Z}_s \\dot{Z}_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^T x=[X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^T . Input: u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T with u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T and u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T . Parameter: p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T , where \\gamma 0 \\gamma>0 is the barrier parameter. Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T , and L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) is the penalty function. Polytopic function (linear constraint): G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T with G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T and G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T T . Number of the discritization grids N=40 N=40 . Discretization method: Euler. Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC NMPC Problem Formulation . Example Quadrotor/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Quadrotor/Simu_Simulink_Setup.m Deployment Example Quadrotor/Simu_Simulink.slx","title":"Simulation: Quadrotor"},{"location":"exp_quadrotor/#quadrotor","text":"Example Quadrotor/ Where you can find this quadrotor M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d ICRA, Shanghai, China, 2011, pp. 763\u2013770.","title":"Quadrotor"},{"location":"exp_quadrotor/#problem-description","text":"The state vector of the quadrotor is x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where (X,Y,Z) (X,Y,Z) and (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha) are the position and angles of the quadrotor, respectively. The state is bounded by [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T . The input vector is u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where a a represents the thrust and (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z}) the rotational rates. The control input is bounded by [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T . The dynamics of the quadrotor are given by the following equations: \\begin{align} \\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ \\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ \\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ \\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ \\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ \\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} The task is to control the quadrotor to track a given position reference under a variable prediction horizon.","title":"Problem Description"},{"location":"exp_quadrotor/#ocp-in-parnmpc","text":"The state constraints are softened by introducing slack variables \\dot{X}_s \\dot{X}_s , \\dot{Y}_s \\dot{Y}_s , and \\dot{Z}_s \\dot{Z}_s . The underlying OCP defined in ParNMPC is formulated as: State: x=[X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^T x=[X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^T . Input: u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T with u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T and u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T . Parameter: p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T , where \\gamma 0 \\gamma>0 is the barrier parameter. Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T , and L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) is the penalty function. Polytopic function (linear constraint): G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T with G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T and G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T T . Number of the discritization grids N=40 N=40 . Discretization method: Euler.","title":"OCP in ParNMPC"},{"location":"exp_quadrotor/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_quadrotor/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC NMPC Problem Formulation . Example Quadrotor/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_quadrotor/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Quadrotor/Simu_Simulink_Setup.m Deployment Example Quadrotor/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_vehicle/","text":"Vehicle Example Vehicle/ Problem Description The state vector of the vehicle is x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} , where (y,z) (y,z) is the position coordinate, v v is the velocity, and \\theta \\theta is the heading angle. The input vector is u=[F,s]^T u=[F,s]^T , where F F is the acceleration force and s s is the steering torque. The control input is bounded by [-5,-1]^T \\leq u \\leq [5,1]^T [-5,-1]^T \\leq u \\leq [5,1]^T . The vehicle starts from position (-2,0) (-2,0) . It's aim is to reach (3.5,2) (3.5,2) while avoiding two obstacles with positions (0,0) (0,0) and (2,2) (2,2) . These constraints are formulated as y^2+z^2\\geq 1 y^2+z^2\\geq 1 and (y-2)^2+(z-2)^2\\geq 1 (y-2)^2+(z-2)^2\\geq 1 . The dynamics of the vehicle are given by the following equations ( m m : mass and I I : moment of inertia): \\begin{align} \\dot{y} = v\\cos(\\theta)\\\\ \\dot{z} = v\\sin(\\theta)\\\\ \\dot{v} = F/m\\\\ \\dot{\\theta} = s/I \\end{align} \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align} OCP in ParNMPC First, the state constraints are transfered into y^2+z^2 = C_{s1} y^2+z^2 = C_{s1} and (y-2)^2+(z-2)^2 = C_{s2} (y-2)^2+(z-2)^2 = C_{s2} with C_{s1}\\geq 1 C_{s1}\\geq 1 and C_{s2}\\geq 2 C_{s2}\\geq 2 . Next, C_{s1}\\geq 1 C_{s1}\\geq 1 and C_{s2}\\geq 2 C_{s2}\\geq 2 are softened by introducing slack variables C_{ss1} C_{ss1} and C_{ss2} C_{ss2} . The underlying OCP defined in ParNMPC is formulated as: State: x=[y,z , v ,\\theta]^T x=[y,z , v ,\\theta]^T . Input: u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T with u_{max}=[5, 1, \\infty, \\infty, \\infty, \\infty]^T u_{max}=[5, 1, \\infty, \\infty, \\infty, \\infty]^T and u_{min} = [-5, -1, -\\infty, 0, -\\infty, 0 ]^T u_{min} = [-5, -1, -\\infty, 0, -\\infty, 0 ]^T . Parameter: p=\\gamma p=\\gamma , where \\gamma 0 \\gamma>0 is the barrier parameter. Equality constraint C(u,x,p) = [y^2 + z^2 - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T C(u,x,p) = [y^2 + z^2 - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T . Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[3.5,2,0,0] x_{ref}=[3.5,2,0,0] , and L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) is the penalty function. Polytopic function (linear constraint) G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1}, C_{s2} - C_{ss2}, C_{s2} + C_{ss2}]^T G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1}, C_{s2} - C_{ss2}, C_{s2} + C_{ss2}]^T with G_{max}=[\\infty,\\infty,\\infty,\\infty]^T G_{max}=[\\infty,\\infty,\\infty,\\infty]^T and G_{min} = [-\\infty,1,-\\infty,1]^T G_{min} = [-\\infty,1,-\\infty,1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T=3 T=3 s. Number of the discritization grids N=48 N=48 . Discretization method: Euler. Closed-loop Simulation using ParNMPC Closed-loop simulation result: Step 1. NMPC problem formulation See Workflow of ParNMPC NMPC Problem Formulation . Example Vehicle/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Vehicle/Simu_Simulink_Setup.m Deployment Example Vehicle/Simu_Simulink.slx","title":"Simulation: Vehicle"},{"location":"exp_vehicle/#vehicle","text":"Example Vehicle/","title":"Vehicle"},{"location":"exp_vehicle/#problem-description","text":"The state vector of the vehicle is x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} , where (y,z) (y,z) is the position coordinate, v v is the velocity, and \\theta \\theta is the heading angle. The input vector is u=[F,s]^T u=[F,s]^T , where F F is the acceleration force and s s is the steering torque. The control input is bounded by [-5,-1]^T \\leq u \\leq [5,1]^T [-5,-1]^T \\leq u \\leq [5,1]^T . The vehicle starts from position (-2,0) (-2,0) . It's aim is to reach (3.5,2) (3.5,2) while avoiding two obstacles with positions (0,0) (0,0) and (2,2) (2,2) . These constraints are formulated as y^2+z^2\\geq 1 y^2+z^2\\geq 1 and (y-2)^2+(z-2)^2\\geq 1 (y-2)^2+(z-2)^2\\geq 1 . The dynamics of the vehicle are given by the following equations ( m m : mass and I I : moment of inertia): \\begin{align} \\dot{y} = v\\cos(\\theta)\\\\ \\dot{z} = v\\sin(\\theta)\\\\ \\dot{v} = F/m\\\\ \\dot{\\theta} = s/I \\end{align} \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align}","title":"Problem Description"},{"location":"exp_vehicle/#ocp-in-parnmpc","text":"First, the state constraints are transfered into y^2+z^2 = C_{s1} y^2+z^2 = C_{s1} and (y-2)^2+(z-2)^2 = C_{s2} (y-2)^2+(z-2)^2 = C_{s2} with C_{s1}\\geq 1 C_{s1}\\geq 1 and C_{s2}\\geq 2 C_{s2}\\geq 2 . Next, C_{s1}\\geq 1 C_{s1}\\geq 1 and C_{s2}\\geq 2 C_{s2}\\geq 2 are softened by introducing slack variables C_{ss1} C_{ss1} and C_{ss2} C_{ss2} . The underlying OCP defined in ParNMPC is formulated as: State: x=[y,z , v ,\\theta]^T x=[y,z , v ,\\theta]^T . Input: u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T with u_{max}=[5, 1, \\infty, \\infty, \\infty, \\infty]^T u_{max}=[5, 1, \\infty, \\infty, \\infty, \\infty]^T and u_{min} = [-5, -1, -\\infty, 0, -\\infty, 0 ]^T u_{min} = [-5, -1, -\\infty, 0, -\\infty, 0 ]^T . Parameter: p=\\gamma p=\\gamma , where \\gamma 0 \\gamma>0 is the barrier parameter. Equality constraint C(u,x,p) = [y^2 + z^2 - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T C(u,x,p) = [y^2 + z^2 - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T . Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[3.5,2,0,0] x_{ref}=[3.5,2,0,0] , and L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) is the penalty function. Polytopic function (linear constraint) G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1}, C_{s2} - C_{ss2}, C_{s2} + C_{ss2}]^T G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1}, C_{s2} - C_{ss2}, C_{s2} + C_{ss2}]^T with G_{max}=[\\infty,\\infty,\\infty,\\infty]^T G_{max}=[\\infty,\\infty,\\infty,\\infty]^T and G_{min} = [-\\infty,1,-\\infty,1]^T G_{min} = [-\\infty,1,-\\infty,1]^T . f(u,x,p) f(u,x,p) is shown before. Prediction horizon T=3 T=3 s. Number of the discritization grids N=48 N=48 . Discretization method: Euler.","title":"OCP in ParNMPC"},{"location":"exp_vehicle/#closed-loop-simulation-using-parnmpc","text":"Closed-loop simulation result:","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_vehicle/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC NMPC Problem Formulation . Example Vehicle/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_vehicle/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC Code Generation and Deployment Simulink . Code generation Example Vehicle/Simu_Simulink_Setup.m Deployment Example Vehicle/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"installation/","text":"Installation Clone or download ParNMPC from Github: ParNMPC . Extract the downloaded file. Requirements ParNMPC supports MATLAB R2016a or later. The following tools are required: MATLAB Coder MATLAB Optimization Toolbox MATLAB Parallel Computing Toolbox MATLAB Symbolic Math Toolbox C/C++ compiler supporting parallel code generation For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check Supported and Compatible Compilers for details. Warning ParNMPC may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds. Check sym bug report for details. Directory Layout The directory layout of ParNMPC is as follows: . \u251c\u2500 ParNMPC/ # Toolkit \u2502 \u251c\u2500 ... \u251c\u2500 docs/ # Homepage \u2502 \u251c\u2500 ... \u251c\u2500 SemiActiveDamper/ # Example of controlling a semi-active damper \u2502 \u251c\u2500 NMPC_Problem_Formulation.m # NMPC formulation and initialization \u2502 \u251c\u2500 Simu_Matlab.m # Closed-loop simulation in MATLAB \u2502 \u251c\u2500 Simu_Simulink.slx # Closed-loop simulation in Simulink \u2502 \u251c\u2500 Simu_Simulink_Setup.m # Setup for the Simulink simulation \u2502 \u251c\u2500 Timer.m # Your own timer function \u2502 \u251c\u2500 GEN_initData.mat # Initial guess \u251c\u2500 DoubleInvertedPendulum/ # Example of swinging up an inverted pendulum \u2502 \u251c\u2500 ... \u2514\u2500 Quadrotor/ # Example of controlling a quadrotor \u2502 \u251c\u2500 ... \u2514\u2500 Vehicle/ # Example of controlling a vehicle \u2502 \u251c\u2500 ... Getting Started This section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example. Run the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler: mex - setup Navigate to the Quadrotor/ folder. cd Quadrotor / Open NMPC_Problem_Formulation.m and run. By running this file, the following things are done: The NMPC controller is defined and configured, and necessary files are automatically generated to the ./funcgen/ and ./codegen/ folders. The very first OCP is solved and its solution is saved to GEN_initData.mat . The controlled plant for simulation is defined and auto-generated. Open Simu_Simulink_Setup.m and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file. Open Simu_Simulink.slx and run. Simu_Simulink.slx calls the generated NMPC controller function from the DLL file. Warning Running Simu_Matlab.m directly is not in parallel.","title":"Installation"},{"location":"installation/#installation","text":"Clone or download ParNMPC from Github: ParNMPC . Extract the downloaded file. Requirements ParNMPC supports MATLAB R2016a or later. The following tools are required: MATLAB Coder MATLAB Optimization Toolbox MATLAB Parallel Computing Toolbox MATLAB Symbolic Math Toolbox C/C++ compiler supporting parallel code generation For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check Supported and Compatible Compilers for details. Warning ParNMPC may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds. Check sym bug report for details.","title":"Installation"},{"location":"installation/#directory-layout","text":"The directory layout of ParNMPC is as follows: . \u251c\u2500 ParNMPC/ # Toolkit \u2502 \u251c\u2500 ... \u251c\u2500 docs/ # Homepage \u2502 \u251c\u2500 ... \u251c\u2500 SemiActiveDamper/ # Example of controlling a semi-active damper \u2502 \u251c\u2500 NMPC_Problem_Formulation.m # NMPC formulation and initialization \u2502 \u251c\u2500 Simu_Matlab.m # Closed-loop simulation in MATLAB \u2502 \u251c\u2500 Simu_Simulink.slx # Closed-loop simulation in Simulink \u2502 \u251c\u2500 Simu_Simulink_Setup.m # Setup for the Simulink simulation \u2502 \u251c\u2500 Timer.m # Your own timer function \u2502 \u251c\u2500 GEN_initData.mat # Initial guess \u251c\u2500 DoubleInvertedPendulum/ # Example of swinging up an inverted pendulum \u2502 \u251c\u2500 ... \u2514\u2500 Quadrotor/ # Example of controlling a quadrotor \u2502 \u251c\u2500 ... \u2514\u2500 Vehicle/ # Example of controlling a vehicle \u2502 \u251c\u2500 ...","title":"Directory Layout"},{"location":"installation/#getting-started","text":"This section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example. Run the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler: mex - setup Navigate to the Quadrotor/ folder. cd Quadrotor / Open NMPC_Problem_Formulation.m and run. By running this file, the following things are done: The NMPC controller is defined and configured, and necessary files are automatically generated to the ./funcgen/ and ./codegen/ folders. The very first OCP is solved and its solution is saved to GEN_initData.mat . The controlled plant for simulation is defined and auto-generated. Open Simu_Simulink_Setup.m and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file. Open Simu_Simulink.slx and run. Simu_Simulink.slx calls the generated NMPC controller function from the DLL file. Warning Running Simu_Matlab.m directly is not in parallel.","title":"Getting Started"},{"location":"interfaces/","text":"Interfaces Classes Class name Description OptimalControlProblem Formulate an OCP NMPCSolver Configurate the NMPC solver OCPSolver Solve the very first OCP offline DynamicSystem Construct a dynamic system OptimalControlProblem Formulate an OCP. Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{lambda,mu,u,x,p} , dimensions of lambda, mu, u, x, p. lambda symbolic vector [xDim,1] , multiplier vector. mu symbolic vector [muDim,1] , multiplier vector. u symbolic vector [uDim,1] , input vector. x symbolic vector [xDim,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [xDim,1] , function f. M symbolic expression [xDim,xDim] , matrix M . L symbolic expression [1,1] , function L. C symbolic expression [muDim,1] , function C. G symbolic expression [GDim,1] , function G. N positive integer [1,1] , number of discretization grids N. T positive [1,1] , prediction horizon T. deltaTau positive [1,1] , discretization size (T/N). discretizationMethod string , discretization method. isMEnabled bool , whether the M matrix is enabled. uMax structure.{value,barrierParameter} , upper bound of u. uMin structure.{value,barrierParameter} , lower bound of u. xMax structure.{value,barrierParameter} , upper bound of x. xMin structure.{value,barrierParameter} , lower bound of x. GMax structure.{value,barrierParameter} , upper bound of G. GMin structure.{value,barrierParameter} , lower bound of G. Functions Description OptimalControlProblem Constructor. Input: muDim : nonnegtive integer [1,1] , dimension of mu. uDim : positive integer [1,1] , dimension of u. xDim : positive integer [1,1] , dimension of x. pDim : nonnegtive integer [1,1] , dimension of p. T : positive [1,1] , prediction horizon. N : positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem setf Set f. Inherit from DynamicSystem setM Set M. Inherit from DynamicSystem setStateName Give names to all or part of the states. Inherit from DynamicSystem setInputName Give names to all or part of the inputs. Inherit from DynamicSystem setParameterName Give names to all or part of the parameters. Inherit from DynamicSystem setL Set L. Input: L : symbolic expression [1,1] , function L. Output: none. setC Set C. Input: C : symbolic expression [muDim,1] , function C. Output: none. setT Set T. Input: T : symbolic variable/double [1,1] , must be included in p if it is a symbolic variable. Output: none. setG Set G. Input: C : symbolic expression [GDim,1] , function G. Output: none. setUpperBound Set the upper bound of u, x, or G. Input: field : string , x , u , or G . boundValue : [~Dim,1] , bound value, i.e., x_{max} x_{max} , u_{max} u_{max} , or G_{max} G_{max} . barrierParameter : positive [~Dim,1] , barrier parameter of the logarithmic function. setLowerBound Set the lower bound of u, x, or G. Input: field : string , x , u , or G . boundValue : [~Dim,1] , bound value, i.e., x_{min} x_{min} , u_{min} u_{min} , or G_{min} G_{min} . barrierParameter : positive [~Dim,1] , barrier parameter of the logarithmic function. setDiscretizationMethod Set the discretization method. Input: method : string , Euler , RK2 , or RK4 , discretization method. Output: none codeGen Generate necessary files. Input: none. Output: none. NMPCSolver Configurate the NMPC solver. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. HessianApproximation string , Hessian approximation method. Functions Description NMPCSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver setHessianApproximation Set the Hessian approximation method. Input: method : string , Newton , GaussNewton , or GaussNewtonLC , Hessian approximation method. Output: none codeGen Generate necessary files. Input: none. Output: none. OCPSolver Solve the very first OCP offline. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. NMPCSolver NMPCSolver , NMPCSolver object. x0 [xDim,1] , initial state. lambda [xDim,N] , multipliers. mu [muDim,N] , multipliers. u [uDim,N] , inputs. x [xDim,N] , states. p [pDim,N] , given parameters. LAMBDA [xDim,xDim,N] , dependent variable LAMBDA. Functions Description OCPSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. NMPCSolver : NMPCSolver , NMPCSolver object. x0 : [xDim,1] , initial state. par : [pDim,N] , given parameters. Output: OCPSolver OCPSolve Solve the OCP with a providing initial guess offline. Input: lambdaInitGuess : [xDim,N] , initial guess of lambda. muInitGuess : [muDim,N] , initial guess of mu. uInitGuess : [uDim,N] , initial guess of u. xInitGuess : [xDim,N] , initial guess of x. method : string , fmincon or NMPC_Iter , solver. maxIter : [1,1] , max number of iterations. Output: lambda : [xDim,N] , optimal value of lambda. mu : [muDim,N] , optimal value of mu. u : [uDim,N] , optimal value of u. x : [xDim,N] , optimal value of x. initFromMatFile Initialize from file with automatic interpolation. Input: matFile : string , file name of the mat file. Output: lambda : [xDim,N] , interpolated value of lambda. mu : [muDim,N] , interpolated value of mu. u : [uDim,N] , interpolated value of u. x : [xDim,N] , interpolated value of x. initFromStartEnd Initialize from the start and the end values by linear interpolation. Input: lambdaStart : [xDim,1] , start value of lambda. muStart : [muDim,1] , start value of mu. uStart : [uDim,1] , start value of u. xStart : [xDim,1] , start value of x. lambdaEnd : [xDim,1] , end value of lambda. muEnd : [muDim,1] , end value of mu. uEnd : [uDim,1] , end value of u. xEnd : [xDim,1] , end value of x. Output: lambda : [xDim,N] , interpolated value of lambda. mu : [muDim,N] , interpolated value of mu. u : [uDim,N] , interpolated value of u. x : [xDim,N] , interpolated value of x. getLAMBDA Get the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p. Input: x0 : [xDim,1] , initial state. lambda : [xDim,N] , lambda. mu : [muDim,N] , mu. u : [uDim,N] , u. x : [xDim,N] , x. p : [pDim,N] , p. Output: LAMBDA : [xDim,xDim,N] . getCost Get the cost function from the given u, x, p. Input: u : [uDim,N] , u. x : [xDim,N] , x. p : [pDim,N] , p. Output: cost : [1,1] . DynamicSystem Construct a dynamic system M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) . Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{u;x;p} , dimensions of u, x, p. u symbolic vector [uDim,1] , input vector. x symbolic vector [xDim,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [xDim,1] , function f. M symbolic expression [xDim,xDim] , matrix M . isMEnabled bool , whether the M matrix is enabled. Functions Description DynamicSystem Constructor. Input: uDim : [1,1] , dimension of u. xDim : [1,1] , dimension of x. pDim : [1,1] , dimension of p. Output: DynamicSystem setf Set f. Input: f : symbolic expression [xDim,1] , function f. Output: none. setM Set M. Input: M : symbolic expression [xDim,xDim] , M matrix. Output: none. setStateName Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({ X , Y , Z }); [X,Z] =~.setStateName({ X , Z },[1 3]); setInputName Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({ F1 , F2 , F3 }; [F1,F3] =~.setInputName({ F1 , F3 },[1 3]); setParameterName Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({ a , b , c }; [a,c] =~.setParameterName({ a , c },[1 3]); codeGen Generate necessary files. Input: none. Output: none. Functions Function name Description NMPC_Iter Perform one iteration to solve the NMPC problem. NMPC_Iter_CodeGen Generate code for function NMPC_Iter . SIM_Plant_RK4 Simulate the dynamic system using the 4-th order Runge-Kutta method. Timer Measure the current time. NMPC_Iter Example ./Simu_Matlab.m Function name NMPC_Iter Description Perform one iteration to solve the NMPC problem. Input x0 : [xDim,1] , initial state. lambda : [xDim,N/DoP,DoP] , initial guess of lambda. mu : [muDim,N/DoP,DoP] , initial guess of mu. u : [uDim,N/DoP,DoP] , initial guess of u. x : [xDim,N/DoP,DoP] , initial guess of x. p : [pDim,N/DoP,DoP] , given parameters. LAMBDA : [xDim,xDim,N/DoP,DoP] , initial guess of LAMBDA. Output lambda : [xDim,N/DoP,DoP] . mu : [muDim,N/DoP,DoP] . u : [uDim,N/DoP,DoP] . x : [xDim,N/DoP,DoP] . LAMBDA : [xDim,xDim,N/DoP,DoP] . cost : [1,1] , evaluation of the cost function after iteration. error : [1,1] , Euclidean norm of the KKT conditions. timeElapsed : [1,1] , computation time in second. NMPC_Iter_CodeGen Example ./Simu_Simulink_Setup.m Function name NMPC_Iter_CodeGen Description Generate code for function NMPC_Iter . Input target : string , mex , dll , or mex , target. targetLang : string , C or ' C++ ', target language. DoP : positive integer [1,1] , degree of parallelism. Output None SIM_Plant_RK4 Example ./Simu_Matlab.m Function name SIM_Plant_RK4 Description Simulate the dynamic system using the 4-th order Runge-Kutta method. Input u : [uDim,1] , inputs applied to the plant. x : [xDim,1] , current state of the plant. p : [pDim,1] , given parameters. Ts : positive [1,1] , sampling interval. Output xNext : [xDim,1] , next state of the plant. Timer Example ./Timer.m Function name Timer Description Measure the current time. Input None Output t : [1,1] , current time. Statement Create Timer.m in the working directory to specify your own timer function.","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"","title":"Interfaces"},{"location":"interfaces/#classes","text":"Class name Description OptimalControlProblem Formulate an OCP NMPCSolver Configurate the NMPC solver OCPSolver Solve the very first OCP offline DynamicSystem Construct a dynamic system","title":"Classes"},{"location":"interfaces/#optimalcontrolproblem","text":"Formulate an OCP. Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{lambda,mu,u,x,p} , dimensions of lambda, mu, u, x, p. lambda symbolic vector [xDim,1] , multiplier vector. mu symbolic vector [muDim,1] , multiplier vector. u symbolic vector [uDim,1] , input vector. x symbolic vector [xDim,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [xDim,1] , function f. M symbolic expression [xDim,xDim] , matrix M . L symbolic expression [1,1] , function L. C symbolic expression [muDim,1] , function C. G symbolic expression [GDim,1] , function G. N positive integer [1,1] , number of discretization grids N. T positive [1,1] , prediction horizon T. deltaTau positive [1,1] , discretization size (T/N). discretizationMethod string , discretization method. isMEnabled bool , whether the M matrix is enabled. uMax structure.{value,barrierParameter} , upper bound of u. uMin structure.{value,barrierParameter} , lower bound of u. xMax structure.{value,barrierParameter} , upper bound of x. xMin structure.{value,barrierParameter} , lower bound of x. GMax structure.{value,barrierParameter} , upper bound of G. GMin structure.{value,barrierParameter} , lower bound of G. Functions Description OptimalControlProblem Constructor. Input: muDim : nonnegtive integer [1,1] , dimension of mu. uDim : positive integer [1,1] , dimension of u. xDim : positive integer [1,1] , dimension of x. pDim : nonnegtive integer [1,1] , dimension of p. T : positive [1,1] , prediction horizon. N : positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem setf Set f. Inherit from DynamicSystem setM Set M. Inherit from DynamicSystem setStateName Give names to all or part of the states. Inherit from DynamicSystem setInputName Give names to all or part of the inputs. Inherit from DynamicSystem setParameterName Give names to all or part of the parameters. Inherit from DynamicSystem setL Set L. Input: L : symbolic expression [1,1] , function L. Output: none. setC Set C. Input: C : symbolic expression [muDim,1] , function C. Output: none. setT Set T. Input: T : symbolic variable/double [1,1] , must be included in p if it is a symbolic variable. Output: none. setG Set G. Input: C : symbolic expression [GDim,1] , function G. Output: none. setUpperBound Set the upper bound of u, x, or G. Input: field : string , x , u , or G . boundValue : [~Dim,1] , bound value, i.e., x_{max} x_{max} , u_{max} u_{max} , or G_{max} G_{max} . barrierParameter : positive [~Dim,1] , barrier parameter of the logarithmic function. setLowerBound Set the lower bound of u, x, or G. Input: field : string , x , u , or G . boundValue : [~Dim,1] , bound value, i.e., x_{min} x_{min} , u_{min} u_{min} , or G_{min} G_{min} . barrierParameter : positive [~Dim,1] , barrier parameter of the logarithmic function. setDiscretizationMethod Set the discretization method. Input: method : string , Euler , RK2 , or RK4 , discretization method. Output: none codeGen Generate necessary files. Input: none. Output: none.","title":"OptimalControlProblem"},{"location":"interfaces/#nmpcsolver","text":"Configurate the NMPC solver. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. HessianApproximation string , Hessian approximation method. Functions Description NMPCSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver setHessianApproximation Set the Hessian approximation method. Input: method : string , Newton , GaussNewton , or GaussNewtonLC , Hessian approximation method. Output: none codeGen Generate necessary files. Input: none. Output: none.","title":"NMPCSolver"},{"location":"interfaces/#ocpsolver","text":"Solve the very first OCP offline. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. NMPCSolver NMPCSolver , NMPCSolver object. x0 [xDim,1] , initial state. lambda [xDim,N] , multipliers. mu [muDim,N] , multipliers. u [uDim,N] , inputs. x [xDim,N] , states. p [pDim,N] , given parameters. LAMBDA [xDim,xDim,N] , dependent variable LAMBDA. Functions Description OCPSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. NMPCSolver : NMPCSolver , NMPCSolver object. x0 : [xDim,1] , initial state. par : [pDim,N] , given parameters. Output: OCPSolver OCPSolve Solve the OCP with a providing initial guess offline. Input: lambdaInitGuess : [xDim,N] , initial guess of lambda. muInitGuess : [muDim,N] , initial guess of mu. uInitGuess : [uDim,N] , initial guess of u. xInitGuess : [xDim,N] , initial guess of x. method : string , fmincon or NMPC_Iter , solver. maxIter : [1,1] , max number of iterations. Output: lambda : [xDim,N] , optimal value of lambda. mu : [muDim,N] , optimal value of mu. u : [uDim,N] , optimal value of u. x : [xDim,N] , optimal value of x. initFromMatFile Initialize from file with automatic interpolation. Input: matFile : string , file name of the mat file. Output: lambda : [xDim,N] , interpolated value of lambda. mu : [muDim,N] , interpolated value of mu. u : [uDim,N] , interpolated value of u. x : [xDim,N] , interpolated value of x. initFromStartEnd Initialize from the start and the end values by linear interpolation. Input: lambdaStart : [xDim,1] , start value of lambda. muStart : [muDim,1] , start value of mu. uStart : [uDim,1] , start value of u. xStart : [xDim,1] , start value of x. lambdaEnd : [xDim,1] , end value of lambda. muEnd : [muDim,1] , end value of mu. uEnd : [uDim,1] , end value of u. xEnd : [xDim,1] , end value of x. Output: lambda : [xDim,N] , interpolated value of lambda. mu : [muDim,N] , interpolated value of mu. u : [uDim,N] , interpolated value of u. x : [xDim,N] , interpolated value of x. getLAMBDA Get the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p. Input: x0 : [xDim,1] , initial state. lambda : [xDim,N] , lambda. mu : [muDim,N] , mu. u : [uDim,N] , u. x : [xDim,N] , x. p : [pDim,N] , p. Output: LAMBDA : [xDim,xDim,N] . getCost Get the cost function from the given u, x, p. Input: u : [uDim,N] , u. x : [xDim,N] , x. p : [pDim,N] , p. Output: cost : [1,1] .","title":"OCPSolver"},{"location":"interfaces/#dynamicsystem","text":"Construct a dynamic system M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) . Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{u;x;p} , dimensions of u, x, p. u symbolic vector [uDim,1] , input vector. x symbolic vector [xDim,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [xDim,1] , function f. M symbolic expression [xDim,xDim] , matrix M . isMEnabled bool , whether the M matrix is enabled. Functions Description DynamicSystem Constructor. Input: uDim : [1,1] , dimension of u. xDim : [1,1] , dimension of x. pDim : [1,1] , dimension of p. Output: DynamicSystem setf Set f. Input: f : symbolic expression [xDim,1] , function f. Output: none. setM Set M. Input: M : symbolic expression [xDim,xDim] , M matrix. Output: none. setStateName Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({ X , Y , Z }); [X,Z] =~.setStateName({ X , Z },[1 3]); setInputName Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({ F1 , F2 , F3 }; [F1,F3] =~.setInputName({ F1 , F3 },[1 3]); setParameterName Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({ a , b , c }; [a,c] =~.setParameterName({ a , c },[1 3]); codeGen Generate necessary files. Input: none. Output: none.","title":"DynamicSystem"},{"location":"interfaces/#functions","text":"Function name Description NMPC_Iter Perform one iteration to solve the NMPC problem. NMPC_Iter_CodeGen Generate code for function NMPC_Iter . SIM_Plant_RK4 Simulate the dynamic system using the 4-th order Runge-Kutta method. Timer Measure the current time.","title":"Functions"},{"location":"interfaces/#nmpc_iter","text":"Example ./Simu_Matlab.m Function name NMPC_Iter Description Perform one iteration to solve the NMPC problem. Input x0 : [xDim,1] , initial state. lambda : [xDim,N/DoP,DoP] , initial guess of lambda. mu : [muDim,N/DoP,DoP] , initial guess of mu. u : [uDim,N/DoP,DoP] , initial guess of u. x : [xDim,N/DoP,DoP] , initial guess of x. p : [pDim,N/DoP,DoP] , given parameters. LAMBDA : [xDim,xDim,N/DoP,DoP] , initial guess of LAMBDA. Output lambda : [xDim,N/DoP,DoP] . mu : [muDim,N/DoP,DoP] . u : [uDim,N/DoP,DoP] . x : [xDim,N/DoP,DoP] . LAMBDA : [xDim,xDim,N/DoP,DoP] . cost : [1,1] , evaluation of the cost function after iteration. error : [1,1] , Euclidean norm of the KKT conditions. timeElapsed : [1,1] , computation time in second.","title":"NMPC_Iter "},{"location":"interfaces/#nmpc_iter_codegen","text":"Example ./Simu_Simulink_Setup.m Function name NMPC_Iter_CodeGen Description Generate code for function NMPC_Iter . Input target : string , mex , dll , or mex , target. targetLang : string , C or ' C++ ', target language. DoP : positive integer [1,1] , degree of parallelism. Output None","title":"NMPC_Iter_CodeGen"},{"location":"interfaces/#sim_plant_rk4","text":"Example ./Simu_Matlab.m Function name SIM_Plant_RK4 Description Simulate the dynamic system using the 4-th order Runge-Kutta method. Input u : [uDim,1] , inputs applied to the plant. x : [xDim,1] , current state of the plant. p : [pDim,1] , given parameters. Ts : positive [1,1] , sampling interval. Output xNext : [xDim,1] , next state of the plant.","title":"SIM_Plant_RK4 "},{"location":"interfaces/#timer","text":"Example ./Timer.m Function name Timer Description Measure the current time. Input None Output t : [1,1] , current time. Statement Create Timer.m in the working directory to specify your own timer function.","title":"Timer"},{"location":"tips/","text":"Tips Solving the Very First OCP In most of the cases, the very first OCP can be solved offline so that warm-start can be used. In solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. Then, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before. Degree of Parallelism (DoP) DoP is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller DoP . In the case of DoP=1 , the solver is exactly equivalent to the interior-point method. Meanwhile, when you want to generate serial code without any parallel computing, you can set DoP to 1 and edit Timer.m to specify your own timer function (the default is omp_get_wtime , which is not supported when OpenMP is disabled). Tuning Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.","title":"Tips"},{"location":"tips/#tips","text":"","title":"Tips"},{"location":"tips/#solving-the-very-first-ocp","text":"In most of the cases, the very first OCP can be solved offline so that warm-start can be used. In solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. Then, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before.","title":"Solving the Very First OCP"},{"location":"tips/#degree-of-parallelism-dop","text":"DoP is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller DoP . In the case of DoP=1 , the solver is exactly equivalent to the interior-point method. Meanwhile, when you want to generate serial code without any parallel computing, you can set DoP to 1 and edit Timer.m to specify your own timer function (the default is omp_get_wtime , which is not supported when OpenMP is disabled).","title":"Degree of Parallelism (DoP)"},{"location":"tips/#tuning","text":"Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.","title":"Tuning"},{"location":"workflow/","text":"Workflow of ParNMPC Preparation Choose a compiler that supports code generation with OpenMP by mex -setup . Edit Timer.m to specify your own timer function. NMPC Problem Formulation Example ./NMPC_Problem_Definition.m Formulate an OCP using Class OptimalControlProblem % Create an OptimalControlProblem object OCP = OptimalControlProblem ( muDim , ... % constraints dim uDim , ... % inputs dim xDim , ... % states dim pDim , ... % parameters dim (position reference) T , ... % prediction horizon N ); % num of discritization grids % Give names to x, u, p (optional) [ ~ ] = OCP . setStateName ( ~ ); [ ~ ] = OCP . setInputName ( ~ ); [ ~ ] = OCP . setParameterName ( ~ ); % Reset the prediction horizon T % (optional for variable horizon or nonuniform discretization) OCP . setT ( ~ ); % Set the dynamic function f OCP . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) OCP . setM ( ~ ); % Set the equality constraint function C (optional) OCP . setC ( ~ ); % Set the cost function L OCP . setL ( ~ ); % Set the bound constraints (optional) OCP . setUpperBound ( u , ~ ); OCP . setLowerBound ( u , ~ ); OCP . setUpperBound ( x , ~ ); OCP . setLowerBound ( x , ~ ); % Set the polytopic constraint G (optional) OCP . setG ( ~ ); OCP . setUpperBound ( G , ~ ); OCP . setLowerBound ( G , ~ ); % Generate necessary files OCP . codeGen (); Configure the solver using Class NMPCSolver % Create a NMPCSolver object nmpcSolver = NMPCSolver ( OCP ); % Configurate the Hessian approximation method nmpcSolver . setHessianApproximation ( ~ ); % Generate necessary files nmpcSolver . codeGen (); Solve the very first OCP for a given initial state and given parameters using Class OCPSolver % Set the initial state x0 = [ ~ ]; % Set the parameters par = [ ~ ]; % Create an OCPSolver object ocpSolver = OCPSolver ( OCP , nmpcSolver , x0 , par ); % Choose one of the following methods to provide an initial guess: % 1. init guess by input lambdaInitGuess = [ ~ ]; muInitGuess = [ ~ ]; uInitGuess = [ ~ ]; xInitGuess = [ ~ ]; % 2. init guess by interpolation [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ] = ... ocpSolver . initFromStartEnd ( ~ ); % 3. init guess from file [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ] = ... ocpSolver . initFromMatFile ( ~ ); % Solve the OCP [ lambda , mu , u , x ] = ocpSolver . OCPSolve ( lambdaInitGuess , ... muInitGuess , ... uInitGuess , ... xInitGuess , ... method ... maxIter ); % Get the dependent variable LAMBDA LAMBDA = ocpSolver . getLAMBDA ( x0 , lambda , mu , u , x , par ); % Check the cost % (optional) cost = ocpSolver . getCost ( u , x , par ); % Save to file for further use save GEN_initData . mat ... x0 lambda mu u x par LAMBDA ~ Define the controlled plant using Class DynamicSystem (optional for simulation) % Create a DynamicSystem object plant = DynamicSystem ( uDim , xDim , pDim ); % Give names to x, u, p (optional) [ ~ ] = plant . setStateName ( ~ ); [ ~ ] = plant . setInputName ( ~ ); [ ~ ] = plant . setParameterName ( ~ ); % Set the dynamic function f plant . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) plant . setM ( ~ ); % Generate necessary files plant . codeGen (); Configuration Table: Configurable discretization method Configurable Hessian approximation method M enabled Euler GaussNewton or GaussNewtonLC M disabled All discretization methods When Euler : All Hessian approximation methods ; When else: GaussNewton or GaussNewtonLC ; Closed-loop Simulation In order to do the closed-loop simulation for the problem defined above, two functions are provided: NMPC_Iter : function of the NMPC solver to carry out one iteration. See Interfaces Functions NMPC_Iter . SIM_Plant_RK4 : one-step simulation of the controlled plant based on the 4-th order Runge-Kutta method. See Interfaces Functions SIM_Plant_RK4 . The degree of parallelism in NMPC_Iter depends on how you slice its input parameters. For example, an input parameter a with shape [aDim,N] split or reshaped into [aDim,N/DoP,DoP] will result in a degree of parallelism of DoP , which can utilize DoP cores to compute in parallel. In the case of DoP=1 , the NMPC solver performs one Newton's (depending on your choice) iteration exactly and is equivalent to the interior-point method. Code Generation and Deployment MATLAB Here, assume your closed-loop simulation is performed in Simu_Matlab.m . Example ./Simu_Matlab.m Code generation Example ./Simu_Matlab_Codegen.m Declare global variables as constants: global discretizationMethod isMEnabled ... uMin uMax xMin xMax GMax GMin ... veryBigNum globalVariable = { discretizationMethod , coder . Constant ( discretizationMethod ), ... isMEnabled , coder . Constant ( isMEnabled ), ... uMax , coder . Constant ( uMax ), ... uMin , coder . Constant ( uMin ), ... xMax , coder . Constant ( xMax ), ... xMin , coder . Constant ( xMin ), ... GMax , coder . Constant ( GMax ), ... GMin , coder . Constant ( GMin ), ... veryBigNum , coder . Constant ( veryBigNum )}; Generate code using codegen : codegen - config : lib Simu_Matlab - globals globalVariable C code will be automatically generated to ./codegen/lib/Simu_Matlab . Deployment in Visual Studio Create an empty Win32 Console Application project. Change to Release x64 mode. Add *.h and *.c files in .\\codegen\\lib\\Simu_Matlab to the project. Add main.h and main.c in .\\codegen\\lib\\Simu_Matlab\\examples to the project. Add directory .\\codegen\\lib\\Simu_Matlab to Properties C/C++ General Additional Include Directories . Properties C/C++ Language Open MP Support: Yes (/openmp) . Compile and run. Simulink Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function NMPC_Iter directly to compute the optimal input. Code generation Example ./Simu_Simulink_Setup.m Define the degree of parallelism: DoP = ~ ; % degree of parallism: 1 = in serial, otherwise in parallel Split \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} , \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} , \\{u_i\\}_{i=1}^{N} \\{u_i\\}_{i=1}^{N} , \\{x_i\\}_{i=1}^{N} \\{x_i\\}_{i=1}^{N} , \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} , and \\{\\Lambda_i\\}_{i=1}^{N} \\{\\Lambda_i\\}_{i=1}^{N} along the prediction horizon into DoP pieces for warm start: sizeSeg = N / DoP ; lambdaSplit = reshape ( lambda , lambdaDim , sizeSeg , DoP ); muSplit = reshape ( mu , muDim , sizeSeg , DoP ); uSplit = reshape ( u , uDim , sizeSeg , DoP ); xSplit = reshape ( x , xDim , sizeSeg , DoP ); pSplit = reshape ( par , pDim , sizeSeg , DoP ); LAMBDASplit = reshape ( LAMBDA , xDim , xDim , sizeSeg , DoP ); Generate dll (lib or mex) and copy it to the working directory: NMPC_Iter_CodeGen ( dll , C , DoP ); copyfile ( ./codegen/dll/NMPC_Iter/NMPC_Iter.dll ); % NMPC_Iter.so in linux Deployment Example ./Simu_Simulink.slx Note This example shows how to call the generated C interface in Simulink using the coder.cevel function within a MATLAB Function block. You can also call the C/C++ interface using S-function. Open the Simulation Target pane in the Simulink Editor: Simulation Model Configuration Parameters Simulation Target . Add #include NMPC_Iter.h to Insert custom C code in generated: Header file . Add the following directory to Additional Build Information: Include directories : ./ codegen / dll / NMPC_Iter Add NMPC_Iter.lib ( NMPC_Iter.so in linux) to Additional Build Information: Libraries . Call the generated C function in a MATLAB Function block in Simulink: coder . ceval ( NMPC_Iter , ... x0 , ... coder . ref ( lambdaSplit ), ... coder . ref ( muSplit ), ... (optional) coder . ref ( uSplit ), ... coder . ref ( xSplit ), ... coder . ref ( pSplit ), ... (optional) coder . ref ( LAMBDASplit ), ... coder . wref ( cost ), ... coder . wref ( error ), ... coder . wref ( timeElapsed )); Accelerating Simulation using MEX-function Code generation Example ./Simu_Simulink_Setup.m Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter ); Deployment Example ./Simu_Matlab.m Modify NMPC_Iter to NMPC_Iter_mex to call the generated mex function: [ lambdaSplit , muSplit , uSplit , xSplit , ... LAMBDASplit , cost , error , timeElapsed ] = NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... uSplit , xSplit , pSplit , ... LAMBDASplit ); and run. MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response. File Dependency Legend\uff1a Advanced Functions From the file dependency, you can even edit directly, e.g., OCP_F_Fu_Fx , to specify your own dynamic function F(u,x,p) F(u,x,p) , and its Jacobians \\partial F/\\partial u \\partial F/\\partial u and \\partial F/\\partial x \\partial F/\\partial x rather than using the auto-generated OCP_GEN_~.m . Currently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling SIM_GEN_~.m .","title":"Workflow"},{"location":"workflow/#workflow-of-parnmpc","text":"","title":"Workflow of ParNMPC"},{"location":"workflow/#preparation","text":"Choose a compiler that supports code generation with OpenMP by mex -setup . Edit Timer.m to specify your own timer function.","title":"Preparation"},{"location":"workflow/#nmpc-problem-formulation","text":"Example ./NMPC_Problem_Definition.m Formulate an OCP using Class OptimalControlProblem % Create an OptimalControlProblem object OCP = OptimalControlProblem ( muDim , ... % constraints dim uDim , ... % inputs dim xDim , ... % states dim pDim , ... % parameters dim (position reference) T , ... % prediction horizon N ); % num of discritization grids % Give names to x, u, p (optional) [ ~ ] = OCP . setStateName ( ~ ); [ ~ ] = OCP . setInputName ( ~ ); [ ~ ] = OCP . setParameterName ( ~ ); % Reset the prediction horizon T % (optional for variable horizon or nonuniform discretization) OCP . setT ( ~ ); % Set the dynamic function f OCP . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) OCP . setM ( ~ ); % Set the equality constraint function C (optional) OCP . setC ( ~ ); % Set the cost function L OCP . setL ( ~ ); % Set the bound constraints (optional) OCP . setUpperBound ( u , ~ ); OCP . setLowerBound ( u , ~ ); OCP . setUpperBound ( x , ~ ); OCP . setLowerBound ( x , ~ ); % Set the polytopic constraint G (optional) OCP . setG ( ~ ); OCP . setUpperBound ( G , ~ ); OCP . setLowerBound ( G , ~ ); % Generate necessary files OCP . codeGen (); Configure the solver using Class NMPCSolver % Create a NMPCSolver object nmpcSolver = NMPCSolver ( OCP ); % Configurate the Hessian approximation method nmpcSolver . setHessianApproximation ( ~ ); % Generate necessary files nmpcSolver . codeGen (); Solve the very first OCP for a given initial state and given parameters using Class OCPSolver % Set the initial state x0 = [ ~ ]; % Set the parameters par = [ ~ ]; % Create an OCPSolver object ocpSolver = OCPSolver ( OCP , nmpcSolver , x0 , par ); % Choose one of the following methods to provide an initial guess: % 1. init guess by input lambdaInitGuess = [ ~ ]; muInitGuess = [ ~ ]; uInitGuess = [ ~ ]; xInitGuess = [ ~ ]; % 2. init guess by interpolation [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ] = ... ocpSolver . initFromStartEnd ( ~ ); % 3. init guess from file [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ] = ... ocpSolver . initFromMatFile ( ~ ); % Solve the OCP [ lambda , mu , u , x ] = ocpSolver . OCPSolve ( lambdaInitGuess , ... muInitGuess , ... uInitGuess , ... xInitGuess , ... method ... maxIter ); % Get the dependent variable LAMBDA LAMBDA = ocpSolver . getLAMBDA ( x0 , lambda , mu , u , x , par ); % Check the cost % (optional) cost = ocpSolver . getCost ( u , x , par ); % Save to file for further use save GEN_initData . mat ... x0 lambda mu u x par LAMBDA ~ Define the controlled plant using Class DynamicSystem (optional for simulation) % Create a DynamicSystem object plant = DynamicSystem ( uDim , xDim , pDim ); % Give names to x, u, p (optional) [ ~ ] = plant . setStateName ( ~ ); [ ~ ] = plant . setInputName ( ~ ); [ ~ ] = plant . setParameterName ( ~ ); % Set the dynamic function f plant . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) plant . setM ( ~ ); % Generate necessary files plant . codeGen (); Configuration Table: Configurable discretization method Configurable Hessian approximation method M enabled Euler GaussNewton or GaussNewtonLC M disabled All discretization methods When Euler : All Hessian approximation methods ; When else: GaussNewton or GaussNewtonLC ;","title":"NMPC Problem Formulation "},{"location":"workflow/#closed-loop-simulation","text":"In order to do the closed-loop simulation for the problem defined above, two functions are provided: NMPC_Iter : function of the NMPC solver to carry out one iteration. See Interfaces Functions NMPC_Iter . SIM_Plant_RK4 : one-step simulation of the controlled plant based on the 4-th order Runge-Kutta method. See Interfaces Functions SIM_Plant_RK4 . The degree of parallelism in NMPC_Iter depends on how you slice its input parameters. For example, an input parameter a with shape [aDim,N] split or reshaped into [aDim,N/DoP,DoP] will result in a degree of parallelism of DoP , which can utilize DoP cores to compute in parallel. In the case of DoP=1 , the NMPC solver performs one Newton's (depending on your choice) iteration exactly and is equivalent to the interior-point method.","title":"Closed-loop Simulation"},{"location":"workflow/#code-generation-and-deployment","text":"","title":"Code Generation and Deployment"},{"location":"workflow/#matlab","text":"Here, assume your closed-loop simulation is performed in Simu_Matlab.m . Example ./Simu_Matlab.m","title":"MATLAB"},{"location":"workflow/#code-generation","text":"Example ./Simu_Matlab_Codegen.m Declare global variables as constants: global discretizationMethod isMEnabled ... uMin uMax xMin xMax GMax GMin ... veryBigNum globalVariable = { discretizationMethod , coder . Constant ( discretizationMethod ), ... isMEnabled , coder . Constant ( isMEnabled ), ... uMax , coder . Constant ( uMax ), ... uMin , coder . Constant ( uMin ), ... xMax , coder . Constant ( xMax ), ... xMin , coder . Constant ( xMin ), ... GMax , coder . Constant ( GMax ), ... GMin , coder . Constant ( GMin ), ... veryBigNum , coder . Constant ( veryBigNum )}; Generate code using codegen : codegen - config : lib Simu_Matlab - globals globalVariable C code will be automatically generated to ./codegen/lib/Simu_Matlab .","title":"Code generation"},{"location":"workflow/#deployment-in-visual-studio","text":"Create an empty Win32 Console Application project. Change to Release x64 mode. Add *.h and *.c files in .\\codegen\\lib\\Simu_Matlab to the project. Add main.h and main.c in .\\codegen\\lib\\Simu_Matlab\\examples to the project. Add directory .\\codegen\\lib\\Simu_Matlab to Properties C/C++ General Additional Include Directories . Properties C/C++ Language Open MP Support: Yes (/openmp) . Compile and run.","title":"Deployment in Visual Studio"},{"location":"workflow/#simulink","text":"Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function NMPC_Iter directly to compute the optimal input.","title":"Simulink "},{"location":"workflow/#code-generation_1","text":"Example ./Simu_Simulink_Setup.m Define the degree of parallelism: DoP = ~ ; % degree of parallism: 1 = in serial, otherwise in parallel Split \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} , \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} , \\{u_i\\}_{i=1}^{N} \\{u_i\\}_{i=1}^{N} , \\{x_i\\}_{i=1}^{N} \\{x_i\\}_{i=1}^{N} , \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} , and \\{\\Lambda_i\\}_{i=1}^{N} \\{\\Lambda_i\\}_{i=1}^{N} along the prediction horizon into DoP pieces for warm start: sizeSeg = N / DoP ; lambdaSplit = reshape ( lambda , lambdaDim , sizeSeg , DoP ); muSplit = reshape ( mu , muDim , sizeSeg , DoP ); uSplit = reshape ( u , uDim , sizeSeg , DoP ); xSplit = reshape ( x , xDim , sizeSeg , DoP ); pSplit = reshape ( par , pDim , sizeSeg , DoP ); LAMBDASplit = reshape ( LAMBDA , xDim , xDim , sizeSeg , DoP ); Generate dll (lib or mex) and copy it to the working directory: NMPC_Iter_CodeGen ( dll , C , DoP ); copyfile ( ./codegen/dll/NMPC_Iter/NMPC_Iter.dll ); % NMPC_Iter.so in linux","title":"Code generation"},{"location":"workflow/#deployment","text":"Example ./Simu_Simulink.slx Note This example shows how to call the generated C interface in Simulink using the coder.cevel function within a MATLAB Function block. You can also call the C/C++ interface using S-function. Open the Simulation Target pane in the Simulink Editor: Simulation Model Configuration Parameters Simulation Target . Add #include NMPC_Iter.h to Insert custom C code in generated: Header file . Add the following directory to Additional Build Information: Include directories : ./ codegen / dll / NMPC_Iter Add NMPC_Iter.lib ( NMPC_Iter.so in linux) to Additional Build Information: Libraries . Call the generated C function in a MATLAB Function block in Simulink: coder . ceval ( NMPC_Iter , ... x0 , ... coder . ref ( lambdaSplit ), ... coder . ref ( muSplit ), ... (optional) coder . ref ( uSplit ), ... coder . ref ( xSplit ), ... coder . ref ( pSplit ), ... (optional) coder . ref ( LAMBDASplit ), ... coder . wref ( cost ), ... coder . wref ( error ), ... coder . wref ( timeElapsed ));","title":"Deployment"},{"location":"workflow/#accelerating-simulation-using-mex-function","text":"Code generation Example ./Simu_Simulink_Setup.m Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter ); Deployment Example ./Simu_Matlab.m Modify NMPC_Iter to NMPC_Iter_mex to call the generated mex function: [ lambdaSplit , muSplit , uSplit , xSplit , ... LAMBDASplit , cost , error , timeElapsed ] = NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... uSplit , xSplit , pSplit , ... LAMBDASplit ); and run. MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.","title":"Accelerating Simulation using MEX-function"},{"location":"workflow/#file-dependency","text":"Legend\uff1a","title":"File Dependency"},{"location":"workflow/#advanced-functions","text":"From the file dependency, you can even edit directly, e.g., OCP_F_Fu_Fx , to specify your own dynamic function F(u,x,p) F(u,x,p) , and its Jacobians \\partial F/\\partial u \\partial F/\\partial u and \\partial F/\\partial x \\partial F/\\partial x rather than using the auto-generated OCP_GEN_~.m . Currently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling SIM_GEN_~.m .","title":"Advanced Functions"}]}