{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC Version 1903-1 ( Github: ParNMPC ) has been released! Introduction ParNMPC is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). The purpose of ParNMPC is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment. With ParNMPC , you can define your own NMPC problem in a very easy way and ParNMPC will automatically generate self-contained C/C++ code for single- or multi-core CPUs. ParNMPC is very fast even with only one core (the computation time is usually in the range of \\mu \\mu s), and a high speedup can be achieved when parallel computing is enabled. Features Symbolic problem representation Automatic parallel C/C++ code generation with OpenMP Fast rate of convergence (up to be superlinear) Highly parallelizable (capable of using at most N cores, N is the # of discretization steps) High speedup ratio MATLAB & Simulink Problems Supported in ParNMPC The optimal control problem (OCP) supported in ParNMPC has the following form: \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & G\\left(u(t),x(t),p(t)\\right)\\geq 0,\\quad t\\in[0,T]. \\end{align} \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & G\\left(u(t),x(t),p(t)\\right)\\geq 0,\\quad t\\in[0,T]. \\end{align} Here, Sign Size Description Sign Size Description u u [dim.u,1] Input vector L L [1,1] Cost function x x [dim.x,1] State vector C C [dim.mu,1] Equality constraint function p p [dim.p,1] Given parameter vector f f [dim.x,1] Dynamics T T [1,1] Prediction horizon M M [dim.x,dim.x] (Optional, e.g., Lagrange model) \\bar{x}_0 \\bar{x}_0 [dim.x,1] Current state vector G G [dim.z,1] Polytopic constraint function ( G G is linear in u u and x x ) Note With the parameter p p , you can achive Time-variant dynamics and references Terminal cost function and constraint How ParNMPC works ParNMPC discretizes the OCP defined above into the following problem with N N steps: \\begin{align} \\min_{x,\\ u}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G(u_i,x_i,p_i) \\geq 0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{x,\\ u}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G(u_i,x_i,p_i) \\geq 0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 is the discretized state-space model. ParNMPC solves the discretized OCP using the parallel primal-dual interior-point method, where the inequality constraints G(u_i,x_i,p_i) \\geq 0 G(u_i,x_i,p_i) \\geq 0 are transferred into logarithmic barrier functions with a barrier parameter \\rho \\rho . Variables Variable Size Description \\lambda \\lambda [dim.lambda,N] Lagrange multiplier corresponding to F F \\mu \\mu [dim.mu,N] Lagrange multiplier corresponding to C C u u [dim.u,N] x x [dim.x,N] z z [dim.z,N] Lagrange multiplier corresponding to G G \\Lambda \\Lambda (LAMBDA) [dim.x,dim.x,N] Sensitivity","title":"Introduction"},{"location":"#parnmpc-a-parallel-computing-toolbox-for-nonlinear-mpc","text":"Version 1903-1 ( Github: ParNMPC ) has been released!","title":"ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC"},{"location":"#introduction","text":"ParNMPC is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). The purpose of ParNMPC is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment. With ParNMPC , you can define your own NMPC problem in a very easy way and ParNMPC will automatically generate self-contained C/C++ code for single- or multi-core CPUs. ParNMPC is very fast even with only one core (the computation time is usually in the range of \\mu \\mu s), and a high speedup can be achieved when parallel computing is enabled.","title":"Introduction"},{"location":"#features","text":"Symbolic problem representation Automatic parallel C/C++ code generation with OpenMP Fast rate of convergence (up to be superlinear) Highly parallelizable (capable of using at most N cores, N is the # of discretization steps) High speedup ratio MATLAB & Simulink","title":"Features"},{"location":"#problems-supported-in-parnmpc","text":"The optimal control problem (OCP) supported in ParNMPC has the following form: \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & G\\left(u(t),x(t),p(t)\\right)\\geq 0,\\quad t\\in[0,T]. \\end{align} \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\ &M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ & C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\ & G\\left(u(t),x(t),p(t)\\right)\\geq 0,\\quad t\\in[0,T]. \\end{align} Here, Sign Size Description Sign Size Description u u [dim.u,1] Input vector L L [1,1] Cost function x x [dim.x,1] State vector C C [dim.mu,1] Equality constraint function p p [dim.p,1] Given parameter vector f f [dim.x,1] Dynamics T T [1,1] Prediction horizon M M [dim.x,dim.x] (Optional, e.g., Lagrange model) \\bar{x}_0 \\bar{x}_0 [dim.x,1] Current state vector G G [dim.z,1] Polytopic constraint function ( G G is linear in u u and x x ) Note With the parameter p p , you can achive Time-variant dynamics and references Terminal cost function and constraint","title":"Problems Supported in  ParNMPC"},{"location":"#how-parnmpc-works","text":"ParNMPC discretizes the OCP defined above into the following problem with N N steps: \\begin{align} \\min_{x,\\ u}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G(u_i,x_i,p_i) \\geq 0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} \\begin{align} \\min_{x,\\ u}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\ &F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ & C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\ & G(u_i,x_i,p_i) \\geq 0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} Here, F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 is the discretized state-space model. ParNMPC solves the discretized OCP using the parallel primal-dual interior-point method, where the inequality constraints G(u_i,x_i,p_i) \\geq 0 G(u_i,x_i,p_i) \\geq 0 are transferred into logarithmic barrier functions with a barrier parameter \\rho \\rho .","title":"How ParNMPC  works"},{"location":"#variables","text":"Variable Size Description \\lambda \\lambda [dim.lambda,N] Lagrange multiplier corresponding to F F \\mu \\mu [dim.mu,N] Lagrange multiplier corresponding to C C u u [dim.u,N] x x [dim.x,N] z z [dim.z,N] Lagrange multiplier corresponding to G G \\Lambda \\Lambda (LAMBDA) [dim.x,dim.x,N] Sensitivity","title":"Variables"},{"location":"about/","text":"About ParNMPC is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka. Citing ParNMPC Citing the parallel algorithm: @article{deng2019parallel, title={A parallel Newton-type method for nonlinear model predictive control}, author={Deng, Haoyang and Ohtsuka, Toshiyuki}, journal={Automatica}, volume={109}, pages={108560}, year={2019}} Citing the toolbox (conference version): @inproceedings{deng2018parallel, title={A parallel code generation toolkit for nonlinear model predictive control}, author={Deng, Haoyang and Ohtsuka, Toshiyuki}, booktitle={Proceedings of the 57th {IEEE} {C}onference on {D}ecision and {C}ontrol}, pages={4920--4926}, year={2018}, address={Miami, USA}} Contacting Us Please do not hesitate to contact us if you have any questions. We would be very happy to hear your advices, experiences, stories, and contributions. You can contact us by: posting an issue on ParNMPC: Issue . E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp joining our QQ Group: 339029295 License ParNMPC is distributed under the BSD 2-Clause \"Simplified\" License.","title":"About"},{"location":"about/#about","text":"ParNMPC is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.","title":"About"},{"location":"about/#citing-parnmpc","text":"Citing the parallel algorithm: @article{deng2019parallel, title={A parallel Newton-type method for nonlinear model predictive control}, author={Deng, Haoyang and Ohtsuka, Toshiyuki}, journal={Automatica}, volume={109}, pages={108560}, year={2019}} Citing the toolbox (conference version): @inproceedings{deng2018parallel, title={A parallel code generation toolkit for nonlinear model predictive control}, author={Deng, Haoyang and Ohtsuka, Toshiyuki}, booktitle={Proceedings of the 57th {IEEE} {C}onference on {D}ecision and {C}ontrol}, pages={4920--4926}, year={2018}, address={Miami, USA}}","title":"Citing ParNMPC"},{"location":"about/#contacting-us","text":"Please do not hesitate to contact us if you have any questions. We would be very happy to hear your advices, experiences, stories, and contributions. You can contact us by: posting an issue on ParNMPC: Issue . E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp joining our QQ Group: 339029295","title":"Contacting Us"},{"location":"about/#license","text":"ParNMPC is distributed under the BSD 2-Clause \"Simplified\" License.","title":"License"},{"location":"exp_damper/","text":"Semi-active Damper Example SemiActiveDamper/ Problem Description A vehicle contacts the wall through the spring and damper: The state vector of the system is x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where y y is the position of the vehicle. The input is the damping coefficient d d , which is constrained with 0\\leq d \\leq 1 0\\leq d \\leq 1 . The dynamic equation of this semi-active damper is m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where k = 1 k = 1 and m=1 m=1 . The task is to control the vehicle's position y y to 0 from an initial position. Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC > NMPC Problem Formulation . Example SemiActiveDamper/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example SemiActiveDamper/Simu_Simulink_Setup.m Deployment Example SemiActiveDamper/Simu_Simulink.slx","title":"Simulation: Semi-active Damper"},{"location":"exp_damper/#semi-active-damper","text":"Example SemiActiveDamper/","title":"Semi-active Damper"},{"location":"exp_damper/#problem-description","text":"A vehicle contacts the wall through the spring and damper: The state vector of the system is x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where y y is the position of the vehicle. The input is the damping coefficient d d , which is constrained with 0\\leq d \\leq 1 0\\leq d \\leq 1 . The dynamic equation of this semi-active damper is m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where k = 1 k = 1 and m=1 m=1 . The task is to control the vehicle's position y y to 0 from an initial position.","title":"Problem Description"},{"location":"exp_damper/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_damper/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC > NMPC Problem Formulation . Example SemiActiveDamper/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_damper/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example SemiActiveDamper/Simu_Simulink_Setup.m Deployment Example SemiActiveDamper/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_double_pendulum/","text":"Double Inverted Pendulum on a Cart Example DoubleInvertedPendulum/ Where you can find this pendulum A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004. Problem Description Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. The pendulum we want to swing up is: The state vector of the system is x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} , where \\theta_0 \\theta_0 is the displacement of the cart, and where \\theta_1 \\theta_1 , \\theta_2 \\theta_2 are the pendulum angles. The displacement is bounded by -0.1 \\leq \\theta_0 \\leq 0.1 -0.1 \\leq \\theta_0 \\leq 0.1 . The control force u u is constrained with |u|\\leq 10 |u|\\leq 10 . The system is modeled as D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu with \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T . The task is to swing up the pendulum from the initial state x_0 = [0,\\pi,\\pi,0,0,0]^{T} x_0 = [0,\\pi,\\pi,0,0,0]^{T} . OCP in ParNMPC The state constraints are softened by introducing a slack variable s\\geq 0 s\\geq 0 with a quadratic penalty on s s . A terminal penalty function is imposed to swing up the pendulum. Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC > NMPC Problem Formulation . Example DoubleInvertedPendulum/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example DoubleInvertedPendulum/Simu_Simulink_Setup.m Deployment Example DoubleInvertedPendulum/Simu_Simulink.slx","title":"Simulation: Double Inverted Pendulum on a Cart"},{"location":"exp_double_pendulum/#double-inverted-pendulum-on-a-cart","text":"Example DoubleInvertedPendulum/ Where you can find this pendulum A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.","title":"Double Inverted Pendulum on a Cart"},{"location":"exp_double_pendulum/#problem-description","text":"Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. The pendulum we want to swing up is: The state vector of the system is x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} x = [\\theta_0,\\dot{\\theta}_0 , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2 ,\\dot{\\theta}_2]^{T} , where \\theta_0 \\theta_0 is the displacement of the cart, and where \\theta_1 \\theta_1 , \\theta_2 \\theta_2 are the pendulum angles. The displacement is bounded by -0.1 \\leq \\theta_0 \\leq 0.1 -0.1 \\leq \\theta_0 \\leq 0.1 . The control force u u is constrained with |u|\\leq 10 |u|\\leq 10 . The system is modeled as D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu with \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T . The task is to swing up the pendulum from the initial state x_0 = [0,\\pi,\\pi,0,0,0]^{T} x_0 = [0,\\pi,\\pi,0,0,0]^{T} .","title":"Problem Description"},{"location":"exp_double_pendulum/#ocp-in-parnmpc","text":"The state constraints are softened by introducing a slack variable s\\geq 0 s\\geq 0 with a quadratic penalty on s s . A terminal penalty function is imposed to swing up the pendulum.","title":"OCP in ParNMPC"},{"location":"exp_double_pendulum/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_double_pendulum/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC > NMPC Problem Formulation . Example DoubleInvertedPendulum/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_double_pendulum/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example DoubleInvertedPendulum/Simu_Simulink_Setup.m Deployment Example DoubleInvertedPendulum/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_heli/","text":"Helicopter Example This example is demonstrated in Version 1808-1. Where you can find this helicopter Quanser website. 3 DoF Helicopter . Model: Benchmark model of Quanser\u2019s 3 DOF Helicopter - 2018 Problem Description The state vector of the helicopter is x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} , where q = [\\epsilon,\\rho,\\lambda]^T q = [\\epsilon,\\rho,\\lambda]^T is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \\rho \\rho is set to be |\\rho|\\leq 1 |\\rho|\\leq 1 . The input vector is u=[V_f,V_b]^T u=[V_f,V_b]^T , where V_f V_f is the voltage on the front motor and V_b V_b is the voltage on the back motor. The control input is bounded by [0,0]^T \\leq u \\leq [20,20]^T [0,0]^T \\leq u \\leq [20,20]^T . The dynamics of the helicopter are given by the following equations: \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} The task is to control the helicopter to track a given yaw reference. Experiment settings: CPU: i7-8700 DoP: 1 Prediction horizon T=4 T=4 s Number of the discritization grids N=48 N=48 Discretization method: Euler Closed-loop control using ParNMPC Experiment results (left: first 15 seconds; right: last 15 seconds):","title":"Experiment: Helicopter"},{"location":"exp_heli/#helicopter","text":"Example This example is demonstrated in Version 1808-1. Where you can find this helicopter Quanser website. 3 DoF Helicopter . Model: Benchmark model of Quanser\u2019s 3 DOF Helicopter - 2018","title":"Helicopter"},{"location":"exp_heli/#problem-description","text":"The state vector of the helicopter is x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} x = [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} , where q = [\\epsilon,\\rho,\\lambda]^T q = [\\epsilon,\\rho,\\lambda]^T is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \\rho \\rho is set to be |\\rho|\\leq 1 |\\rho|\\leq 1 . The input vector is u=[V_f,V_b]^T u=[V_f,V_b]^T , where V_f V_f is the voltage on the front motor and V_b V_b is the voltage on the back motor. The control input is bounded by [0,0]^T \\leq u \\leq [20,20]^T [0,0]^T \\leq u \\leq [20,20]^T . The dynamics of the helicopter are given by the following equations: \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} \\begin{align*} \\ddot{q} = &-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ 0 \\end{array} \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon & & \\\\ & C_\\rho& \\\\ & & C_\\lambda \\end{array} \\right]\\dot{q}\\\\ &+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)& 0 \\\\ 0 & b_{\\rho}\\\\ b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0 \\end{array} \\right]u \\end{align*} The task is to control the helicopter to track a given yaw reference. Experiment settings: CPU: i7-8700 DoP: 1 Prediction horizon T=4 T=4 s Number of the discritization grids N=48 N=48 Discretization method: Euler","title":"Problem Description"},{"location":"exp_heli/#closed-loop-control-using-parnmpc","text":"Experiment results (left: first 15 seconds; right: last 15 seconds):","title":"Closed-loop control using ParNMPC"},{"location":"exp_quadrotor/","text":"Quadrotor Example Quadrotor/ Where you can find this quadrotor M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d ICRA, Shanghai, China, 2011, pp. 763\u2013770. Problem Description The state vector of the quadrotor is x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where (X,Y,Z) (X,Y,Z) and (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha) are the position and angles of the quadrotor, respectively. The state is bounded by [-0.2,-0.2,-0.2]^T \\leq [\\gamma,\\beta,\\alpha]^T \\leq [0.2,0.2,0.2]^T [-0.2,-0.2,-0.2]^T \\leq [\\gamma,\\beta,\\alpha]^T \\leq [0.2,0.2,0.2]^T . The input vector is u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where a a represents the thrust and (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z}) the rotational rates. The control input is bounded by [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T . The dynamics of the quadrotor are given by the following equations: \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} The task is to control the quadrotor to track a given position reference. OCP in ParNMPC The state constraints are softened by introducing a slack variable s\\geq 0 s\\geq 0 with a quadratic penalty on s s . Closed-loop Simulation using ParNMPC Step 1. NMPC problem formulation See Workflow of ParNMPC > NMPC Problem Formulation . Example Quadrotor/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example Quadrotor/Simu_Simulink_Setup.m Deployment Example Quadrotor/Simu_Simulink.slx","title":"Simulation: Quadrotor"},{"location":"exp_quadrotor/#quadrotor","text":"Example Quadrotor/ Where you can find this quadrotor M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d ICRA, Shanghai, China, 2011, pp. 763\u2013770.","title":"Quadrotor"},{"location":"exp_quadrotor/#problem-description","text":"The state vector of the quadrotor is x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x = [X,\\dot{X} , Y ,\\dot{Y} ,Z ,\\dot{Z} ,\\gamma ,\\beta ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where (X,Y,Z) (X,Y,Z) and (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha) are the position and angles of the quadrotor, respectively. The state is bounded by [-0.2,-0.2,-0.2]^T \\leq [\\gamma,\\beta,\\alpha]^T \\leq [0.2,0.2,0.2]^T [-0.2,-0.2,-0.2]^T \\leq [\\gamma,\\beta,\\alpha]^T \\leq [0.2,0.2,0.2]^T . The input vector is u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where a a represents the thrust and (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z}) the rotational rates. The control input is bounded by [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T . The dynamics of the quadrotor are given by the following equations: \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} \\begin{align} &\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &\\dot{\\gamma} = (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} The task is to control the quadrotor to track a given position reference.","title":"Problem Description"},{"location":"exp_quadrotor/#ocp-in-parnmpc","text":"The state constraints are softened by introducing a slack variable s\\geq 0 s\\geq 0 with a quadratic penalty on s s .","title":"OCP in ParNMPC"},{"location":"exp_quadrotor/#closed-loop-simulation-using-parnmpc","text":"","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_quadrotor/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC > NMPC Problem Formulation . Example Quadrotor/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_quadrotor/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example Quadrotor/Simu_Simulink_Setup.m Deployment Example Quadrotor/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"exp_vehicle/","text":"Vehicle Example Vehicle/ Problem Description The state vector of the vehicle is x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} , where (y,z) (y,z) is the position coordinate, v v is the velocity, and \\theta \\theta is the heading angle. The input vector is u=[F,s]^T u=[F,s]^T , where F F is the acceleration force and s s is the steering torque. The control input is bounded by [-5,-1]^T \\leq u \\leq [5,1]^T [-5,-1]^T \\leq u \\leq [5,1]^T . The vehicle starts from position (-2,0) (-2,0) . It's aim is to reach (3.5,2) (3.5,2) while avoiding two obstacles with positions (0,0) (0,0) and (2,2) (2,2) . These constraints are formulated as y^2+z^2\\geq 1 y^2+z^2\\geq 1 and (y-2)^2+(z-2)^2\\geq 1 (y-2)^2+(z-2)^2\\geq 1 . The dynamics of the vehicle are given by the following equations ( m m : mass and I I : moment of inertia): \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align} \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align} OCP in ParNMPC The nonlinear constraints are transfered into y^2+z^2 = C_{1} y^2+z^2 = C_{1} and (y-2)^2+(z-2)^2 = C_{2} (y-2)^2+(z-2)^2 = C_{2} with C_{1}\\geq 1 C_{1}\\geq 1 and C_{2}\\geq 1 C_{2}\\geq 1 . The state constraints C_{1}\\geq 1 C_{1}\\geq 1 and C_{2}\\geq 1 C_{2}\\geq 1 are softened by introducing a positive slack variable. Closed-loop Simulation using ParNMPC Closed-loop simulation result: Step 1. NMPC problem formulation See Workflow of ParNMPC > NMPC Problem Formulation . Example Vehicle/NMPC_Problem_Formulation.m Step 2. Code generation and deployment in Simulink See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example Vehicle/Simu_Simulink_Setup.m Deployment Example Vehicle/Simu_Simulink.slx","title":"Simulation: Vehicle"},{"location":"exp_vehicle/#vehicle","text":"Example Vehicle/","title":"Vehicle"},{"location":"exp_vehicle/#problem-description","text":"The state vector of the vehicle is x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} x = [y,z , v ,\\theta]^{T}\\in\\mathbb{R}^{4} , where (y,z) (y,z) is the position coordinate, v v is the velocity, and \\theta \\theta is the heading angle. The input vector is u=[F,s]^T u=[F,s]^T , where F F is the acceleration force and s s is the steering torque. The control input is bounded by [-5,-1]^T \\leq u \\leq [5,1]^T [-5,-1]^T \\leq u \\leq [5,1]^T . The vehicle starts from position (-2,0) (-2,0) . It's aim is to reach (3.5,2) (3.5,2) while avoiding two obstacles with positions (0,0) (0,0) and (2,2) (2,2) . These constraints are formulated as y^2+z^2\\geq 1 y^2+z^2\\geq 1 and (y-2)^2+(z-2)^2\\geq 1 (y-2)^2+(z-2)^2\\geq 1 . The dynamics of the vehicle are given by the following equations ( m m : mass and I I : moment of inertia): \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align} \\begin{align} &\\dot{y} = v\\cos(\\theta)\\\\ &\\dot{z} = v\\sin(\\theta)\\\\ &\\dot{v} = F/m\\\\ &\\dot{\\theta} = s/I \\end{align}","title":"Problem Description"},{"location":"exp_vehicle/#ocp-in-parnmpc","text":"The nonlinear constraints are transfered into y^2+z^2 = C_{1} y^2+z^2 = C_{1} and (y-2)^2+(z-2)^2 = C_{2} (y-2)^2+(z-2)^2 = C_{2} with C_{1}\\geq 1 C_{1}\\geq 1 and C_{2}\\geq 1 C_{2}\\geq 1 . The state constraints C_{1}\\geq 1 C_{1}\\geq 1 and C_{2}\\geq 1 C_{2}\\geq 1 are softened by introducing a positive slack variable.","title":"OCP in ParNMPC"},{"location":"exp_vehicle/#closed-loop-simulation-using-parnmpc","text":"Closed-loop simulation result:","title":"Closed-loop Simulation using ParNMPC"},{"location":"exp_vehicle/#step-1-nmpc-problem-formulation","text":"See Workflow of ParNMPC > NMPC Problem Formulation . Example Vehicle/NMPC_Problem_Formulation.m","title":"Step 1. NMPC problem formulation"},{"location":"exp_vehicle/#step-2-code-generation-and-deployment-in-simulink","text":"See Workflow of ParNMPC > Code Generation and Deployment > Simulink . Code generation Example Vehicle/Simu_Simulink_Setup.m Deployment Example Vehicle/Simu_Simulink.slx","title":"Step 2. Code generation and deployment in Simulink"},{"location":"installation/","text":"Installation Clone or download ParNMPC from Github: ParNMPC . Extract the downloaded file. Requirements ParNMPC supports MATLAB R2016a or later. The following tools are required: MATLAB Coder MATLAB Optimization Toolbox MATLAB Parallel Computing Toolbox MATLAB Symbolic Math Toolbox Simulink Coder C/C++ compiler supporting parallel code generation For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check Supported and Compatible Compilers for details. Warning ParNMPC may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds. Check sym bug report for details. Directory Layout The directory layout of ParNMPC is as follows: . \u251c\u2500 ParNMPC/ # Toolkit \u2502 \u251c\u2500 ... \u251c\u2500 docs/ # Homepage \u2502 \u251c\u2500 ... \u251c\u2500 SemiActiveDamper/ # Example of controlling a semi-active damper \u2502 \u251c\u2500 NMPC_Problem_Formulation.m # NMPC formulation and initialization \u2502 \u251c\u2500 Simu_Matlab.m # Closed-loop simulation in MATLAB \u2502 \u251c\u2500 Simu_Matlab_Codegen.m # Executable file generation for Simu_Matlab.m \u2502 \u251c\u2500 Simu_Simulink.slx # Closed-loop simulation in Simulink \u2502 \u251c\u2500 Simu_Simulink_Setup.m # Setup for the Simulink simulation \u2502 \u251c\u2500 Timer.m # Your own timer function \u251c\u2500 DoubleInvertedPendulum/ # Example of swinging up an inverted pendulum \u2502 \u251c\u2500 ... \u2514\u2500 Quadrotor/ # Example of controlling a quadrotor \u2502 \u251c\u2500 ... \u2514\u2500 Vehicle/ # Example of controlling a vehicle \u2502 \u251c\u2500 ... Getting Started This example shows how to perform a Simulink closed-loop simulation in MATLAB R2018b. Select the Microsoft Visual C++ 2017 (C) compiler: >> mex - setup Navigate to the Quadrotor/ folder. >> cd Quadrotor / Open NMPC_Problem_Formulation.m and run. Open Simu_Simulink_Setup.m and run. Open Simu_Simulink.slx and run.","title":"Installation"},{"location":"installation/#installation","text":"Clone or download ParNMPC from Github: ParNMPC . Extract the downloaded file. Requirements ParNMPC supports MATLAB R2016a or later. The following tools are required: MATLAB Coder MATLAB Optimization Toolbox MATLAB Parallel Computing Toolbox MATLAB Symbolic Math Toolbox Simulink Coder C/C++ compiler supporting parallel code generation For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check Supported and Compatible Compilers for details. Warning ParNMPC may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds. Check sym bug report for details.","title":"Installation"},{"location":"installation/#directory-layout","text":"The directory layout of ParNMPC is as follows: . \u251c\u2500 ParNMPC/ # Toolkit \u2502 \u251c\u2500 ... \u251c\u2500 docs/ # Homepage \u2502 \u251c\u2500 ... \u251c\u2500 SemiActiveDamper/ # Example of controlling a semi-active damper \u2502 \u251c\u2500 NMPC_Problem_Formulation.m # NMPC formulation and initialization \u2502 \u251c\u2500 Simu_Matlab.m # Closed-loop simulation in MATLAB \u2502 \u251c\u2500 Simu_Matlab_Codegen.m # Executable file generation for Simu_Matlab.m \u2502 \u251c\u2500 Simu_Simulink.slx # Closed-loop simulation in Simulink \u2502 \u251c\u2500 Simu_Simulink_Setup.m # Setup for the Simulink simulation \u2502 \u251c\u2500 Timer.m # Your own timer function \u251c\u2500 DoubleInvertedPendulum/ # Example of swinging up an inverted pendulum \u2502 \u251c\u2500 ... \u2514\u2500 Quadrotor/ # Example of controlling a quadrotor \u2502 \u251c\u2500 ... \u2514\u2500 Vehicle/ # Example of controlling a vehicle \u2502 \u251c\u2500 ...","title":"Directory Layout"},{"location":"installation/#getting-started","text":"This example shows how to perform a Simulink closed-loop simulation in MATLAB R2018b. Select the Microsoft Visual C++ 2017 (C) compiler: >> mex - setup Navigate to the Quadrotor/ folder. >> cd Quadrotor / Open NMPC_Problem_Formulation.m and run. Open Simu_Simulink_Setup.m and run. Open Simu_Simulink.slx and run.","title":"Getting Started"},{"location":"interfaces/","text":"Interfaces Classes Class name Description OptimalControlProblem Formulate an OCP NMPCSolver Configurate the NMPC solver DynamicSystem Construct a dynamic system OptimalControlProblem Formulate an OCP. Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{lambda,mu,u,x,z,p} , dimensions of lambda, mu, u, x, z, p. lambda symbolic vector [dim.x,1] , multiplier vector. mu symbolic vector [dim.mu,1] , multiplier vector. u symbolic vector [dim.u,1] , input vector. x symbolic vector [dim.x,1] , state vector. z symbolic vector [zDim,1] , multiplier vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [dim.x,1] , function f. M symbolic expression [dim.x,dim.x] , matrix M . L symbolic expression [1,1] , function L. C symbolic expression [dim.mu,1] , function C. G symbolic expression [dim.z,1] , function G. N positive integer [1,1] , number of discretization grids N. T positive [1,1] , prediction horizon T. deltaTau positive [1,1] , discretization size (T/N). discretizationMethod string , discretization method. isMEnabled bool , whether the M matrix is enabled. Functions Description OptimalControlProblem Constructor. Input: dim.u : positive integer [1,1] , dimension of u. dim.x : positive integer [1,1] , dimension of x. pDim : nonnegtive integer [1,1] , dimension of p. N : positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem setf Set f. Inherit from DynamicSystem setM Set M. Inherit from DynamicSystem setStateName Give names to all or part of the states. Inherit from DynamicSystem setInputName Give names to all or part of the inputs. Inherit from DynamicSystem setParameterName Give names to all or part of the parameters. Inherit from DynamicSystem setL Set L. Input: L : symbolic expression [1,1] , function L. Output: none. setC Set C. Input: C : symbolic expression [dim.mu,1] , function C. Output: none. setT Set T. Input: T : symbolic variable/double [1,1] , must be included in p if it is a symbolic variable. Output: none. setG Set G. Input: C : symbolic expression [dim.z,1] , function G. Output: none. setDiscretizationMethod Set the discretization method. Input: method : string , 'Euler' , 'RK2' , or 'RK4' , discretization method. Output: none codeGen Generate necessary files. Input: none. Output: none. NMPCSolver Configurate the NMPC solver. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. HessianApproximation string , Hessian approximation method. Functions Description NMPCSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver setHessianApproximation Set the Hessian approximation method. Input: method : string , 'Newton' , 'GaussNewton' , or 'GaussNewtonLC' , Hessian approximation method. Output: none codeGen Generate necessary files. Input: none. Output: none. DynamicSystem Construct a dynamic system M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) . Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{u;x;p} , dimensions of u, x, p. u symbolic vector [dim.u,1] , input vector. x symbolic vector [dim.x,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [dim.x,1] , function f. M symbolic expression [dim.x,dim.x] , matrix M . isMEnabled bool , whether the M matrix is enabled. Functions Description DynamicSystem Constructor. Input: dim.u : [1,1] , dimension of u. dim.x : [1,1] , dimension of x. pDim : [1,1] , dimension of p. Output: DynamicSystem setf Set f. Input: f : symbolic expression [dim.x,1] , function f. Output: none. setM Set M. Input: M : symbolic expression [dim.x,dim.x] , M matrix. Output: none. setStateName Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({'X','Y','Z'}); [X,Z] =~.setStateName({'X','Z'},[1 3]); setInputName Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({'F1','F2','F3'}; [F1,F3] =~.setInputName({'F1','F3'},[1 3]); setParameterName Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({'a','b','c'}; [a,c] =~.setParameterName({'a','c'},[1 3]); codeGen Generate necessary files. Input: none. Output: none. Functions Function name Description NMPC_Solve Solve the NMPC problem. createOptions Create an option struct for NMPC_Solve . NMPC_Solve_CodeGen Generate code for NMPC_Solve . SIM_Plant_RK4 Simulate the dynamic system using the 4-th order Runge-Kutta method. Timer Measure the current time. NMPC_Solve Example ./Simu_Matlab.m Function name NMPC_Solve Description Solve the NMPC problem. Input x0 : [dim.x,1] , initial state. p : [pDim,N] , given parameters. options : struct , options. Output solution : struct , solution. output : struct , output information. createOptions Example ./Simu_Matlab.m Function name createOptions Description Create an option struct for NMPC_Solve . Input None Output options : struct , options. NMPC_Solve_CodeGen Example ./Simu_Simulink_Setup.m Function name NMPC_Solve_CodeGen Description Generate code for function NMPC_Solve . Input target : string , 'mex' , 'dll' , or 'mex' , target. targetLang : string , 'C' or ' C++ ', target language. options : struct , options. Output None SIM_Plant_RK4 Example ./Simu_Matlab.m Function name SIM_Plant_RK4 Description Simulate the dynamic system using the 4-th order Runge-Kutta method. Input u : [dim.u,1] , inputs applied to the plant. x : [dim.x,1] , current state of the plant. p : [pDim,1] , given parameters. Ts : positive [1,1] , sampling interval. Output xNext : [dim.x,1] , next state of the plant. Timer Example ./Timer.m Function name Timer Description Measure the current time. Input None Output t : [1,1] , current time. Statement Create Timer.m in the working directory to specify your own timer function.","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"","title":"Interfaces"},{"location":"interfaces/#classes","text":"Class name Description OptimalControlProblem Formulate an OCP NMPCSolver Configurate the NMPC solver DynamicSystem Construct a dynamic system","title":"Classes"},{"location":"interfaces/#optimalcontrolproblem","text":"Formulate an OCP. Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{lambda,mu,u,x,z,p} , dimensions of lambda, mu, u, x, z, p. lambda symbolic vector [dim.x,1] , multiplier vector. mu symbolic vector [dim.mu,1] , multiplier vector. u symbolic vector [dim.u,1] , input vector. x symbolic vector [dim.x,1] , state vector. z symbolic vector [zDim,1] , multiplier vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [dim.x,1] , function f. M symbolic expression [dim.x,dim.x] , matrix M . L symbolic expression [1,1] , function L. C symbolic expression [dim.mu,1] , function C. G symbolic expression [dim.z,1] , function G. N positive integer [1,1] , number of discretization grids N. T positive [1,1] , prediction horizon T. deltaTau positive [1,1] , discretization size (T/N). discretizationMethod string , discretization method. isMEnabled bool , whether the M matrix is enabled. Functions Description OptimalControlProblem Constructor. Input: dim.u : positive integer [1,1] , dimension of u. dim.x : positive integer [1,1] , dimension of x. pDim : nonnegtive integer [1,1] , dimension of p. N : positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem setf Set f. Inherit from DynamicSystem setM Set M. Inherit from DynamicSystem setStateName Give names to all or part of the states. Inherit from DynamicSystem setInputName Give names to all or part of the inputs. Inherit from DynamicSystem setParameterName Give names to all or part of the parameters. Inherit from DynamicSystem setL Set L. Input: L : symbolic expression [1,1] , function L. Output: none. setC Set C. Input: C : symbolic expression [dim.mu,1] , function C. Output: none. setT Set T. Input: T : symbolic variable/double [1,1] , must be included in p if it is a symbolic variable. Output: none. setG Set G. Input: C : symbolic expression [dim.z,1] , function G. Output: none. setDiscretizationMethod Set the discretization method. Input: method : string , 'Euler' , 'RK2' , or 'RK4' , discretization method. Output: none codeGen Generate necessary files. Input: none. Output: none.","title":"OptimalControlProblem"},{"location":"interfaces/#nmpcsolver","text":"Configurate the NMPC solver. Example ./NMPC_Problem_Formulation.m Properties Description OCP OptimalControlProblem , OptimalControlProblem object. HessianApproximation string , Hessian approximation method. Functions Description NMPCSolver Constructor. Input: OCP : OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver setHessianApproximation Set the Hessian approximation method. Input: method : string , 'Newton' , 'GaussNewton' , or 'GaussNewtonLC' , Hessian approximation method. Output: none codeGen Generate necessary files. Input: none. Output: none.","title":"NMPCSolver"},{"location":"interfaces/#dynamicsystem","text":"Construct a dynamic system M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) . Example ./NMPC_Problem_Formulation.m Properties Description dim structure.{u;x;p} , dimensions of u, x, p. u symbolic vector [dim.u,1] , input vector. x symbolic vector [dim.x,1] , state vector. p symbolic vector [pDim,1] , parameter vector. f symbolic expression [dim.x,1] , function f. M symbolic expression [dim.x,dim.x] , matrix M . isMEnabled bool , whether the M matrix is enabled. Functions Description DynamicSystem Constructor. Input: dim.u : [1,1] , dimension of u. dim.x : [1,1] , dimension of x. pDim : [1,1] , dimension of p. Output: DynamicSystem setf Set f. Input: f : symbolic expression [dim.x,1] , function f. Output: none. setM Set M. Input: M : symbolic expression [dim.x,dim.x] , M matrix. Output: none. setStateName Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({'X','Y','Z'}); [X,Z] =~.setStateName({'X','Z'},[1 3]); setInputName Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({'F1','F2','F3'}; [F1,F3] =~.setInputName({'F1','F3'},[1 3]); setParameterName Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({'a','b','c'}; [a,c] =~.setParameterName({'a','c'},[1 3]); codeGen Generate necessary files. Input: none. Output: none.","title":"DynamicSystem"},{"location":"interfaces/#functions","text":"Function name Description NMPC_Solve Solve the NMPC problem. createOptions Create an option struct for NMPC_Solve . NMPC_Solve_CodeGen Generate code for NMPC_Solve . SIM_Plant_RK4 Simulate the dynamic system using the 4-th order Runge-Kutta method. Timer Measure the current time.","title":"Functions"},{"location":"interfaces/#nmpc_solve","text":"Example ./Simu_Matlab.m Function name NMPC_Solve Description Solve the NMPC problem. Input x0 : [dim.x,1] , initial state. p : [pDim,N] , given parameters. options : struct , options. Output solution : struct , solution. output : struct , output information.","title":"NMPC_Solve "},{"location":"interfaces/#createoptions","text":"Example ./Simu_Matlab.m Function name createOptions Description Create an option struct for NMPC_Solve . Input None Output options : struct , options.","title":"createOptions"},{"location":"interfaces/#nmpc_solve_codegen","text":"Example ./Simu_Simulink_Setup.m Function name NMPC_Solve_CodeGen Description Generate code for function NMPC_Solve . Input target : string , 'mex' , 'dll' , or 'mex' , target. targetLang : string , 'C' or ' C++ ', target language. options : struct , options. Output None","title":"NMPC_Solve_CodeGen"},{"location":"interfaces/#sim_plant_rk4","text":"Example ./Simu_Matlab.m Function name SIM_Plant_RK4 Description Simulate the dynamic system using the 4-th order Runge-Kutta method. Input u : [dim.u,1] , inputs applied to the plant. x : [dim.x,1] , current state of the plant. p : [pDim,1] , given parameters. Ts : positive [1,1] , sampling interval. Output xNext : [dim.x,1] , next state of the plant.","title":"SIM_Plant_RK4 "},{"location":"interfaces/#timer","text":"Example ./Timer.m Function name Timer Description Measure the current time. Input None Output t : [1,1] , current time. Statement Create Timer.m in the working directory to specify your own timer function.","title":"Timer"},{"location":"tips/","text":"Tips Solving the Very First OCP In most of the cases, the very first OCP can be solved offline to provide an accurate initial guess. In solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. Then, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before. Degree of Parallelism (DoP) DoP is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller DoP . In the case of DoP=1 , the solver is exactly equivalent to the primal-dual interior-point method. Meanwhile, when you want to generate serial code without any parallel computing, you can set DoP to 1 and edit Timer.m to specify your own timer function (the default is omp_get_wtime , which is not supported when OpenMP is disabled). Tuning Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.","title":"Tips"},{"location":"tips/#tips","text":"","title":"Tips"},{"location":"tips/#solving-the-very-first-ocp","text":"In most of the cases, the very first OCP can be solved offline to provide an accurate initial guess. In solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. Then, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before.","title":"Solving the Very First OCP"},{"location":"tips/#degree-of-parallelism-dop","text":"DoP is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller DoP . In the case of DoP=1 , the solver is exactly equivalent to the primal-dual interior-point method. Meanwhile, when you want to generate serial code without any parallel computing, you can set DoP to 1 and edit Timer.m to specify your own timer function (the default is omp_get_wtime , which is not supported when OpenMP is disabled).","title":"Degree of Parallelism (DoP)"},{"location":"tips/#tuning","text":"Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.","title":"Tuning"},{"location":"workflow/","text":"Workflow of ParNMPC Preparation Choose a compiler that supports code generation with OpenMP by mex -setup . Edit Timer.m to specify your own timer function. NMPC Problem Formulation Example ./NMPC_Problem_Definition.m Formulate an OCP using Class OptimalControlProblem % Create an OptimalControlProblem object OCP = OptimalControlProblem ( dim . u , ... % inputs dim dim . x , ... % states dim dim . p , ... % parameters dim N ); % num of discretization grids % Give names to x, u, p (optional) [ ~ ] = OCP . setStateName ( ~ ); [ ~ ] = OCP . setInputName ( ~ ); [ ~ ] = OCP . setParameterName ( ~ ); % Set the prediction horizon T OCP . setT ( ~ ); % Set the dynamic function f OCP . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) OCP . setM ( ~ ); % Set the equality constraint function C (optional) OCP . setC ( ~ ); % Set the cost function L OCP . setL ( ~ ); % Set the polytopic constraint G (optional) OCP . setG ( ~ ); % Generate necessary files OCP . codeGen (); Configure the solver using Class NMPCSolver % Create a NMPCSolver object nmpcSolver = NMPCSolver ( OCP ); % Configurate the Hessian approximation method nmpcSolver . setHessianApproximation ( ~ ); % Configurate the descent regularization parameter (optional) nmpcSolver . setDescentRegularization ( ~ ); % Generate necessary files nmpcSolver . codeGen (); Solve the very first OCP offline to provide an accurate initial guess % Set the initial state x0 = [ ~ ]; % Set the parameters p = [~] ; % Create an initial guess solutionInitGuess = [ ~ ]; % Solve the optimal control problem for given values of x0 and p % with barrier parameter rho solution = NMPC_SolveOffline ( x0 , p , solutionInitGuess , rho , maxIter ); % Save to file for Simu_Matlab.m save GEN_initData.mat dim x0 p N % Set initial guess global ParNMPCGlobalVariable ParNMPCGlobalVariable . solutionInitGuess = solution ; Define the controlled plant using Class DynamicSystem (optional for simulation) % Create a DynamicSystem object plant = DynamicSystem ( dim . u , dim . x , dim . p ); % Give names to x, u, p (optional) [ ~ ] = plant . setStateName ( ~ ); [ ~ ] = plant . setInputName ( ~ ); [ ~ ] = plant . setParameterName ( ~ ); % Set the dynamic function f plant . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) plant . setM ( ~ ); % Generate necessary files plant . codeGen (); Configuration Table: Configurable discretization method Configurable Hessian approximation method M enabled 'Euler' 'GaussNewton' M disabled All All Closed-loop Simulation In order to do the closed-loop simulation for the problem defined above, two functions are provided: NMPC_Solve : function of the NMPC solver. See Interfaces > Functions > NMPC_Solve . SIM_Plant_RK4 : one-step simulation of the controlled plant based on the 4-th order Runge-Kutta method. See Interfaces > Functions > SIM_Plant_RK4 . Code Generation and Deployment MATLAB Here, assume your closed-loop simulation is performed in Simu_Matlab.m . Example ./Simu_Matlab.m Code generation Example ./Simu_Matlab_Codegen.m An executable file that performs the closed-loop simulation will be generated automatically. Simulink Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function NMPC_Solve directly to compute the optimal input. Code generation Example ./Simu_Simulink_Setup.m Define and configurate options for NMPC_Solve: options = createOptions (); Generate code: NMPC_Solve_CodeGen ( ~ , ~ , options ); Deployment Example ./Simu_Simulink.slx This example shows how to call the generated C interface in Simulink using the coder.cevel function within a MATLAB Function block. You can also call the C/C++ interface using S-function. Open the Simulation Target pane in the Simulink Editor: Simulation > Model Configuration Parameters > Simulation Target . Add #include \"NMPC_Solve.h\" to Insert custom C code in generated: Header file . Add NMPC_Solve_initialize(); to Insert custom C code in generated: Initialize function . Add NMPC_Solve_terminate(); to Insert custom C code in generated: Terminate function . Add the following directory to Additional Build Information: Include directories : ./ codegen /~/ NMPC_Solve Add NMPC_Solve.lib ( NMPC_Solve.so in linux) to Additional Build Information: Libraries . Call the generated C function in a MATLAB Function block in Simulink: output = createOutput (); solution = createNonemptySolution (); coder . ceval ( 'NMPC_Solve' , ... x0 , ... p , ... % (optional) coder . wref ( solution ), ... coder . wref ( output )); Note Alternatively, steps 1-6 can be done using the following commands. Simu_Simulink set_param('Simu_Simulink', 'SimCustomHeaderCode', '#include \"NMPC_Solve.h\"') set_param('Simu_Simulink', 'SimCustomInitializer', 'NMPC_Solve_initialize();') set_param('Simu_Simulink', 'SimCustomTerminator', 'NMPC_Solve_terminate();') set_param('Simu_Simulink', 'SimUserLibraries', 'NMPC_Solve.lib') set_param('Simu_Simulink', 'SimUserIncludeDirs', './codegen/~/NMPC_Solve') Accelerating Simulation using MEX-function Code generation Example ./Simu_Simulink_Setup.m Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to mex : NMPC_Solve_CodeGen ( 'mex' , 'C' , options ); Deployment Example ./Simu_Matlab.m Modify NMPC_Solve to NMPC_Solve_mex to call the generated mex function and run. MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.","title":"Workflow"},{"location":"workflow/#workflow-of-parnmpc","text":"","title":"Workflow of ParNMPC"},{"location":"workflow/#preparation","text":"Choose a compiler that supports code generation with OpenMP by mex -setup . Edit Timer.m to specify your own timer function.","title":"Preparation"},{"location":"workflow/#nmpc-problem-formulation","text":"Example ./NMPC_Problem_Definition.m Formulate an OCP using Class OptimalControlProblem % Create an OptimalControlProblem object OCP = OptimalControlProblem ( dim . u , ... % inputs dim dim . x , ... % states dim dim . p , ... % parameters dim N ); % num of discretization grids % Give names to x, u, p (optional) [ ~ ] = OCP . setStateName ( ~ ); [ ~ ] = OCP . setInputName ( ~ ); [ ~ ] = OCP . setParameterName ( ~ ); % Set the prediction horizon T OCP . setT ( ~ ); % Set the dynamic function f OCP . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) OCP . setM ( ~ ); % Set the equality constraint function C (optional) OCP . setC ( ~ ); % Set the cost function L OCP . setL ( ~ ); % Set the polytopic constraint G (optional) OCP . setG ( ~ ); % Generate necessary files OCP . codeGen (); Configure the solver using Class NMPCSolver % Create a NMPCSolver object nmpcSolver = NMPCSolver ( OCP ); % Configurate the Hessian approximation method nmpcSolver . setHessianApproximation ( ~ ); % Configurate the descent regularization parameter (optional) nmpcSolver . setDescentRegularization ( ~ ); % Generate necessary files nmpcSolver . codeGen (); Solve the very first OCP offline to provide an accurate initial guess % Set the initial state x0 = [ ~ ]; % Set the parameters p = [~] ; % Create an initial guess solutionInitGuess = [ ~ ]; % Solve the optimal control problem for given values of x0 and p % with barrier parameter rho solution = NMPC_SolveOffline ( x0 , p , solutionInitGuess , rho , maxIter ); % Save to file for Simu_Matlab.m save GEN_initData.mat dim x0 p N % Set initial guess global ParNMPCGlobalVariable ParNMPCGlobalVariable . solutionInitGuess = solution ; Define the controlled plant using Class DynamicSystem (optional for simulation) % Create a DynamicSystem object plant = DynamicSystem ( dim . u , dim . x , dim . p ); % Give names to x, u, p (optional) [ ~ ] = plant . setStateName ( ~ ); [ ~ ] = plant . setInputName ( ~ ); [ ~ ] = plant . setParameterName ( ~ ); % Set the dynamic function f plant . setf ( ~ ); % Set the matrix M (optional for, e.g., Lagrange model) plant . setM ( ~ ); % Generate necessary files plant . codeGen (); Configuration Table: Configurable discretization method Configurable Hessian approximation method M enabled 'Euler' 'GaussNewton' M disabled All All","title":"NMPC Problem Formulation "},{"location":"workflow/#closed-loop-simulation","text":"In order to do the closed-loop simulation for the problem defined above, two functions are provided: NMPC_Solve : function of the NMPC solver. See Interfaces > Functions > NMPC_Solve . SIM_Plant_RK4 : one-step simulation of the controlled plant based on the 4-th order Runge-Kutta method. See Interfaces > Functions > SIM_Plant_RK4 .","title":"Closed-loop Simulation"},{"location":"workflow/#code-generation-and-deployment","text":"","title":"Code Generation and Deployment"},{"location":"workflow/#matlab","text":"Here, assume your closed-loop simulation is performed in Simu_Matlab.m . Example ./Simu_Matlab.m","title":"MATLAB"},{"location":"workflow/#code-generation","text":"Example ./Simu_Matlab_Codegen.m An executable file that performs the closed-loop simulation will be generated automatically.","title":"Code generation"},{"location":"workflow/#simulink","text":"Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function NMPC_Solve directly to compute the optimal input.","title":"Simulink "},{"location":"workflow/#code-generation_1","text":"Example ./Simu_Simulink_Setup.m Define and configurate options for NMPC_Solve: options = createOptions (); Generate code: NMPC_Solve_CodeGen ( ~ , ~ , options );","title":"Code generation"},{"location":"workflow/#deployment","text":"Example ./Simu_Simulink.slx This example shows how to call the generated C interface in Simulink using the coder.cevel function within a MATLAB Function block. You can also call the C/C++ interface using S-function. Open the Simulation Target pane in the Simulink Editor: Simulation > Model Configuration Parameters > Simulation Target . Add #include \"NMPC_Solve.h\" to Insert custom C code in generated: Header file . Add NMPC_Solve_initialize(); to Insert custom C code in generated: Initialize function . Add NMPC_Solve_terminate(); to Insert custom C code in generated: Terminate function . Add the following directory to Additional Build Information: Include directories : ./ codegen /~/ NMPC_Solve Add NMPC_Solve.lib ( NMPC_Solve.so in linux) to Additional Build Information: Libraries . Call the generated C function in a MATLAB Function block in Simulink: output = createOutput (); solution = createNonemptySolution (); coder . ceval ( 'NMPC_Solve' , ... x0 , ... p , ... % (optional) coder . wref ( solution ), ... coder . wref ( output )); Note Alternatively, steps 1-6 can be done using the following commands. Simu_Simulink set_param('Simu_Simulink', 'SimCustomHeaderCode', '#include \"NMPC_Solve.h\"') set_param('Simu_Simulink', 'SimCustomInitializer', 'NMPC_Solve_initialize();') set_param('Simu_Simulink', 'SimCustomTerminator', 'NMPC_Solve_terminate();') set_param('Simu_Simulink', 'SimUserLibraries', 'NMPC_Solve.lib') set_param('Simu_Simulink', 'SimUserIncludeDirs', './codegen/~/NMPC_Solve')","title":"Deployment"},{"location":"workflow/#accelerating-simulation-using-mex-function","text":"Code generation Example ./Simu_Simulink_Setup.m Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to mex : NMPC_Solve_CodeGen ( 'mex' , 'C' , options ); Deployment Example ./Simu_Matlab.m Modify NMPC_Solve to NMPC_Solve_mex to call the generated mex function and run. MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.","title":"Accelerating Simulation using MEX-function"}]}